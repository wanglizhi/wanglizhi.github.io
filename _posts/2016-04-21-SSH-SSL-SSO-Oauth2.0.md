---
layout:     post
title:      "SSL SSH SSO OAuth2.0，理解万岁~"
subtitle:   "什么都略懂一点，生活更多彩一些"
date:       2016-04-21 23:30:00
author:     "Wanglizhi"
header-img: "img/home-bg.jpg"
catalog:    true
tags:

    - 计算机网络
    - SSH
    - SSL
    - OAuth2.0
    - HTTPS
    - 名词理解

---

> 本博客的第一篇文章，内容四处搜罗，水滴石穿，贵在坚持！

**一句话名词解释**

- SSL（Secure Sockets Layer）：其继任者“传输层安全”（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。
- SSH（Secure Shell）：一种建立在应用层和传输层基础上的安全协议，用于计算机之间的加密登录。
- SSO（Single Sign On）：单点登录，多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。
- OAuth2.0：允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。

## 密码学知识

- 加密方法可以分为两大类。一类是单钥加密（private key cryptography），还有一类叫做双钥加密（public key cryptography）。前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是两套密码。
- 在单钥加密的情况下，密钥只有一把，所以密钥的保存变得很重要。一旦密钥泄漏，密码也就被破解。
- 在双钥加密的情况下，密钥有两把，一把是公开的公钥，还有一把是不公开的私钥。

双钥加密的原理如下：

> a) 公钥和私钥是一一对应的关系，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立。
>
> b) 所有的（公钥, 私钥）对都是不同的。
>
> c) 用公钥可以解开私钥加密的信息，反之亦成立。
>
> d) 同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的。


- 目前，通用的单钥加密算法为DES（Data Encryption Standard），通用的双钥加密算法为**RSA**（ Rivest-Shamir-Adleman），都产生于上个世纪70年代。
- 在双钥体系中，公钥用来加密信息，私钥用来数字签名。
- 因为任何人都可以生成自己的（公钥，私钥）对，所以为了防止有人散布伪造的公钥骗取信任，就需要一个可靠的第三方机构来生成经过认证的（公钥，私钥）对。目前，世界上最主要的数字服务认证商是位于美国加州的Verisign公司，它的主要业务就是分发RSA数字证书。

## 数字签名和数字证书

> 数字签名：消息正文经过Hash后生成摘要，发送者使用**私钥**对这个摘要进行加密即“数字签名”，然后将数字签名连通正文一并发送。接收者收到后，使用**公钥**对数字签名进行解密并生成摘要，然后与正文Hash后的结果进行对比，如果一致则安全。
>
> 数字证书：简单的公钥有可能被替换，从而伪造消息。于是，证书中心（CA，certificate authority）就使用自己的私钥对用户的公钥和一些相关信息进行加密，生成数字证书。发送者将消息正文、数字签名和数字证书一并发送，接收者拿到后用CA的公钥解锁发送者的公钥。

![](http://image.beekka.com/blog/201108/bg2011080913.png)

#### 应用数字证书的例子：https协议

- 首先，客户端向服务器发出加密请求
- 服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。
- 客户端（浏览器）的"证书管理器"，有"受信任的根证书颁发机构"列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。
- 如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。
- 如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。
- 如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。

**参考** [数字签名是什么？](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)

## SSL

#### 作用

不使用ssl/tls的HTTP通道，就是不加密的通信。所有信息明文传播，带来了三大风险。

- 窃听风险（eavesdropping）：第三方可以获知通信内容。
- 篡改风险（tampering）：第三方可以修改通信内容。
- 冒充风险（pretending）：第三方可以冒充他人身份参与通信。

SSL设计的目的：

- 所有信息都是加密的，第三方无法窃听
- 具有校验机制，一旦被篡改，通信双方会立刻发现。
- 配备身份证书，防止身份被冒充。

#### 基本运行过程

SSL协议采用公钥加密算法，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

两个问题：
> 如何保证公钥不被篡改？解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。
>
> 公钥加密计算量太大，如何减少耗用的时间？解决方法：每一次对话（session），客户端和服务器端都生成一个**"对话密钥"**（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。

所以基本过程是：

- （1） 客户端向服务器端索要并验证公钥。
- （2） 双方协商生成"对话密钥"。
- （3） 双方采用"对话密钥"进行加密通信。

#### 握手阶段的详细过程

![](http://image.beekka.com/blog/201402/bg2014020502.png)

- 客户端发送请求（ClientHello）：发送加密通信请求，内容包括（支持的协议版本、**客户端生成的随机数**、支持的加密算法、支持的压缩算法）
- 服务器回应（ServerHello）：确认使用的协议版本，**一个服务器生成的随机数**，确认加密算法，服务器证书
- 客户端回应：首先验证证书，有问题则警告；没问题则从证书中取出服务器公钥，发送一下内容（一个使用该公钥加密的**随机数pre-master-key**、编码改变通知、客户端握手结束通知）
- 服务器最后回应：使用三个随机数生成“会话密钥”，发送（编码改变通知，服务器握手结束通知）

接下来客户端和服务器使用http协议通信，使用“会话密钥”加密内容。

**参考** [SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)

## SSH

#### 什么是SSH

（secure shell）
使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。

SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。

好用的客户端：Windows 客户端putty； Mac 客户端zoc

#### 最基本的用法

```
$ ssh -p 2222 user@host
```

#### 中间人攻击

SSH基本过程：

- （1）远程主机收到用户的登录请求，把自己的公钥发给用户。
- （2）用户使用这个公钥，将登录密码加密后，发送回来。
- （3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。

因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。所以有可能会产生"中间人攻击"（Man-in-the-middle attack）

#### 口令登陆

第一次登录对方主机时，系统会提示RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，Are you sure you want to continue connecting (yes/no)?

当用户决定接受这个远程主机的公钥，host主机就得到认可，要求输入密码。
当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。

每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。

#### 公钥登陆（git的ssh key）

原理：用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。

```
　$ ssh-keygen // 生成公钥
```

在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。

将公钥传送到远程主机host上

```
$ ssh-copy-id user@host
// 然后重启远程主机ssh服务
// ubuntu系统
service ssh restart
// debian系统
/etc/init.d/ssh restart
```

远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。

**参考** [SSH原理与运用（一）：远程登录](http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html)

[SSH原理与运用（二）：远程操作与端口转发](http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html)

## SSO

单点登录（ Single Sign-On , 简称 SSO ）是目前比较流行的服务于企业业务整合的解决方案之一， SSO使得在多个应用系统中，用户只需要**登录一次**就可以访问所有相互信任的应用系统。

#### 单点登陆的优点

- 工作效率提高：提高员工工作效率，简化应用系统操作过程。
- 增加安全性：强大的身份认证，规避密码安全风险，增加信息系统安全性。
- 降低管理成本：降低管理员工作强度，节省人力投入到更多有意义的IT 建设工作中。
- 实施风险最少：强大的技术支撑，缩短应用部署周期。
- 提高开发人员的效率。SSO 为开发人员提供了一个通用的身份验证框架。实际上，如果 SSO 机制是独立的，那么开发人员就完全不需要为身份验证操心。

#### 单点登陆的缺点

- 单点故障。在使用单点登录时，所有应用程序使用一个集中的身份验证服务。当集中地身份验证服务发生故障时，将导致所有系统无法登录。

#### 单点登陆的主要技术

- Cookie：用户登录任意一个受信任的系统后，在当前系统的域名下写入登录令牌的Cookie。
- Broker-based(基于经纪人)，例如Kerberos等。
- 在一个基于经纪人的SSO解决方案中，有一个集中的认证和用户账号管理的服务器。经纪人给能被用于进一步请求的电子的身份存取。中央数据库的使用减少了管理的代价，并为认证提供一个公共和独立的"第三方"。
- 基于安全断言标记语言(SAML)实现，SAML（Security Assertion Markup Language，安全断言标记语言）的出现大大简化了SSO，并被OASIS批准为SSO的执行标准

#### CAS单点登陆技术

CAS（Central Authentication Service）是耶鲁大学开发的单点登录（Single Sign On）系统。CAS应用广泛，具有独立于平台，易于理解，支持代理等功能。

下面是这个身份验证协议中的主要步骤：

- 用户尝试使用应用程序的 URL 访问应用程序。如果在本地不存在用户登录信息的Cookie，用户将被重定向到 CAS Server登录 URL，采用的是 HTTPS 连接，他请求的应用程序URL作为参数传递。这时CAS Server向用户显示一个用户名/密码对话框。
- 用户输入 ID 和密码，CAS 对他进行身份验证。如果身份验证失败，CAS Server提示失败信息。应用程序并不知道这个用户试图访问它。
- 如果身份验证成功，CAS 就将用户重定向回目标应用程序，并在 URL 中附加一个称为 ticket (Service Ticket,该ticket是由一串随机数产生，用于客户端和应用程序之间的身份验证)的参数，然后，CAS 尝试创建一个称为 ticket-granting cookie 的内存 cookie。这是为了以后进行自动的重新验证；如果存在这个 cookie，就表示这个用户已经成功地登录了，用户就不需要再次输入他的用户名和密码。
- 然后，应用程序要检查这个 ticket 是否正确，以及是否代表一个有效用户；检查的方法是，打开一个 HTTPS 连接来调用 CAS serviceValidate URL，并作为参数传递 ticket 和服务名称。CAS 检查这个 ticket 是否有效，以及是否与请求的服务相关联。如果检查成功，CAS 就将用户名返回给应用程序，并跳转到要访问的应用程序URL。

![](http://static.open-open.com/lib/uploadImg/20150523/20150523193942_202.jpg)

**参考** [CAS实现SSO单点登录原理](http://www.open-open.com/lib/view/open1432381488005.html)

**拓展** [编写你自己的单点登录（SSO）服务](http://blog.csdn.net/javachannel/article/details/752437/)

## OAuth2.0

OAuth是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是2.0版。

#### OAuth的思路

OAuth在"客户端"与"服务提供商"之间，设置了一个授权层（authorization layer）。"客户端"不能直接登录"服务提供商"，只能登录授权层，以此将用户与客户端区分开来。"客户端"登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。

"客户端"登录授权层以后，"服务提供商"根据令牌的权限范围和有效期，向"客户端"开放用户储存的资料。

#### 运行流程

![](http://image.beekka.com/blog/2014/bg2014051203.png)

- （A）用户打开客户端以后，客户端要求用户给予授权。
- （B）用户同意给予客户端**授权**。
- （C）客户端使用上一步获得的授权，向认证服务器申请令牌。
- （D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。
- （E）客户端使用令牌，向资源服务器申请获取资源。
- （F）资源服务器确认令牌无误，同意向客户端开放资源。

#### 客户端授权模式

- 授权码模式（authorization code），是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与"服务提供商"的认证服务器进行互动。
- 简化模式（implicit），不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了"授权码"这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。
- 密码模式（resource owner password credentials），用户向客户端提供自己的用户名和密码。客户端使用这些信息，向"服务商提供商"索要授权。
- 客户端模式（client credentials），指客户端以自己的名义，而不是以用户的名义，向"服务提供商"进行认证。

#### 更新令牌

如果用户访问的时候，客户端的"访问令牌"已经过期，则需要使用"更新令牌"申请一个新的访问令牌。

客户端发出更新令牌的HTTP请求，包含以下参数：
granttype：表示使用的授权模式，此处的值固定为"refreshtoken"，必选项。

refresh_token：表示早前收到的更新令牌，必选项。

scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。

**参考** [理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)



