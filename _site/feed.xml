<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lizhi Blog</title>
    <description>机会只留给有准备的人</description>
    <link>http://wanglizhi.github.io/</link>
    <atom:link href="http://wanglizhi.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 24 Apr 2016 13:37:00 +0000</pubDate>
    <lastBuildDate>Sun, 24 Apr 2016 13:37:00 +0000</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>Git 详解~</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;能长期在Github活跃，为开源项目做贡献，是程序员学习的最好状态，很难也很简单，是我追求的目标！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;有个坑提醒下：jekyll 的date指定的日期比实际时间少8小时&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;概括&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。&lt;/p&gt;

&lt;p&gt;在大三之前都是用subversion，目前业界基本都是Git了，学会Git成了开发者的必备技能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Git常用命令参考（长期更新）&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git fetch
git merge origin/master
git mergetool // 解决冲突工具
git reset —hard HEAD~1 // 回退到上个版本
git reset --hard 版本号 // 回退到某个版本
git remote set -url origin URL // 本地修改远程地址
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;git-&quot;&gt;Git 远程操作详解&lt;/h2&gt;

&lt;p&gt;Git有很多优势，其中之一就是远程操作非常简便。下面将详细介绍5个Git命令：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;git clone&lt;/li&gt;
  &lt;li&gt;git remote&lt;/li&gt;
  &lt;li&gt;git fetch&lt;/li&gt;
  &lt;li&gt;git pull&lt;/li&gt;
  &lt;li&gt;git push&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/2014/bg2014061202.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;git-clone&quot;&gt;git clone&lt;/h4&gt;

&lt;p&gt;git clone支持多种协议地址&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone &amp;lt;版本库的网址&amp;gt;
$ git clone http[s]://example.com/path/to/repo.git/
$ git clone ssh://example.com/path/to/repo.git/
$ git clone git://example.com/path/to/repo.git/
$ git clone /opt/git/project.git 
$ git clone file:///opt/git/project.git
$ git clone ftp[s]://example.com/path/to/repo.git/
$ git clone rsync://example.com/path/to/repo.git/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。&lt;/p&gt;

&lt;h4 id=&quot;git-remote&quot;&gt;git remote&lt;/h4&gt;

&lt;p&gt;Git要求每个远程主机都必须指定一个主机名。&lt;code class=&quot;highlighter-rouge&quot;&gt;git remote&lt;/code&gt;命令就用于管理主机名。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git remote
origin
$ git remote -v
origin  git@github.com:jquery/jquery.git (fetch)
origin  git@github.com:jquery/jquery.git (push)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;克隆版本库的时候，所使用的远程主机自动被Git命名为&lt;code class=&quot;highlighter-rouge&quot;&gt;origin&lt;/code&gt;。如果想用其他的主机名，需要用&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone&lt;/code&gt;命令的&lt;code class=&quot;highlighter-rouge&quot;&gt;-o&lt;/code&gt;选项指定。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone -o jQuery https://github.com/jquery/jquery.git
$ git remote
jQuery
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;删除、添加、重命名远程主机的命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git remote show &amp;lt;主机名&amp;gt;
$ git remote add &amp;lt;主机名&amp;gt; &amp;lt;网址&amp;gt;
$ git remote rm &amp;lt;主机名&amp;gt;
$ git remote rename &amp;lt;原主机名&amp;gt; &amp;lt;新主机名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;git-fetch&quot;&gt;git fetch&lt;/h4&gt;

&lt;p&gt;将远程主机版本库更新取回本地&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git fetch &amp;lt;远程主机名&amp;gt;
// 默认取回所有分支的更新，也可以指定分支
$ git fetch &amp;lt;远程主机名&amp;gt; &amp;lt;分支名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在本地主机上要用”远程主机名/分支名”的形式读取。比如&lt;code class=&quot;highlighter-rouge&quot;&gt;origin&lt;/code&gt;主机的&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;，就要用&lt;code class=&quot;highlighter-rouge&quot;&gt;origin/master&lt;/code&gt;读取。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch&lt;/code&gt;命令的&lt;code class=&quot;highlighter-rouge&quot;&gt;-r&lt;/code&gt;选项，可以用来查看远程分支，&lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt;选项查看所有分支。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git branch -r
origin/master

$ git branch -a
* master
  remotes/origin/master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;取回远程主机的更新以后，可以在它的基础上，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout&lt;/code&gt;命令创建一个新的分支。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git checkout -b newBrach origin/master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此外，也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt;命令或者&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt;命令，在本地分支上合并远程分支。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git merge origin/master
# 或者
$ git rebase origin/master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;git-pull&quot;&gt;git pull&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt;命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果合并需要采用rebase模式，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;--rebase&lt;/code&gt;选项&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git pull --rebase &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果远程主机删除了某个分支，默认情况下，&lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt; 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致&lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt;不知不觉删除了本地分支。&lt;/p&gt;

&lt;p&gt;但是，你可以改变这个行为，加上参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt; 就会在本地删除远程已经删除的分支。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git pull -p
# 等同于下面的命令
$ git fetch --prune origin 
$ git fetch -p
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;git-push&quot;&gt;git push&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git push&lt;/code&gt;命令用于将本地分支的更新，推送到远程主机。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt;:&amp;lt;远程分支名&amp;gt;
$ git push origin master
// 将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git push origin :master
# 等同于
$ git push origin --delete master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做&lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt;合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;--force&lt;/code&gt;选项。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git push --force origin 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面命令使用&lt;code class=&quot;highlighter-rouge&quot;&gt;--force&lt;/code&gt;选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用&lt;code class=&quot;highlighter-rouge&quot;&gt;--force&lt;/code&gt;选项。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt; &lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/06/git_remote.html&quot;&gt;Git远程操作详解&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;git--1&quot;&gt;Git 使用规范流程&lt;/h2&gt;

&lt;p&gt;团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的。&lt;/p&gt;

&lt;p&gt;下面是&lt;a href=&quot;https://github.com/thoughtbot/guides/tree/master/protocol/git&quot;&gt;ThoughtBot&lt;/a&gt; 的Git使用规范流程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015080501.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;第一步：新建分支&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 获取主干最新代码
$ git checkout master
$ git pull

# 新建一个开发分支myfeature
$ git checkout -b myfeature
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;commit&quot;&gt;第二步：提交分支commit&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add --all // 等于git add . 
$ git status
$ git commit --verbose
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;git commit 命令的verbose参数，会列出 &lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html&quot;&gt;diff&lt;/a&gt; 的结果。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;第三步：撰写提交信息&lt;/h4&gt;

&lt;p&gt;提交commit时，必须给出完整扼要的提交信息&lt;/p&gt;

&lt;p&gt;第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、以及需要注意的问题。最后，提供对应的网址（比如Bug ticket）。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;第四步：与主干同步&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git fetch origin
$ git rebase origin/master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;git rebase用于把一个分支的修改合并到当前分支，而那些老的提交会被丢弃。 如果运行垃圾收集命令(pruning garbage collection), 这些被丢弃的提交就会删除.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://my.csdn.net/uploads/201206/14/1339682976_4523.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;commit-1&quot;&gt;第五步：合并commit&lt;/h4&gt;

&lt;p&gt;分支开发完成后，很可能有一堆commit，但是合并到主干的时候，往往希望只有一个（或最多两三个）commit，这样不仅清晰，也容易管理。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rebase -i origin/master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;git rebase命令的i参数表示互动（interactive），这时git会打开一个互动界面，进行下一步操作。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;第六步：推送到远程仓库&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git push --force origin myfeature
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;git push命令要加上force参数，因为rebase以后，分支历史改变了，跟远程分支不一定兼容，有可能要强行推送（&lt;strong&gt;实际开发慎用force&lt;/strong&gt;）&lt;/p&gt;

&lt;h4 id=&quot;pull-request&quot;&gt;第七步：发出Pull Request&lt;/h4&gt;

&lt;p&gt;提交到远程仓库以后，就可以发出 Pull Request 到master分支，然后请求别人进行代码review，确认可以合并到master。&lt;/p&gt;

&lt;h4 id=&quot;git-merge--git-rebase-history&quot;&gt;git merge 对比 git rebase (history)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://my.csdn.net/uploads/201206/14/1339683149_4793.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于使用git merge来合并所看到的commit的顺序（从新到旧）是：C7 ,C6,C4,C5,C3,C2,C1&lt;/p&gt;

&lt;p&gt;对于使用git rebase来合并所看到的commit的顺序（从新到旧）是：C7 ,C6‘,C5’,C4,C3,C2,C1&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt; &lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/08/git-use-process.html&quot;&gt;Git 使用规范流程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[&lt;a href=&quot;http://blog.csdn.net/hudashi/article/details/7664631&quot;&gt;git rebase简介(基本篇)&lt;/a&gt;]&lt;/p&gt;
</description>
        <pubDate>Sun, 24 Apr 2016 12:00:00 +0000</pubDate>
        <link>http://wanglizhi.github.io/2016/04/24/Git/</link>
        <guid isPermaLink="true">http://wanglizhi.github.io/2016/04/24/Git/</guid>
        
        <category>Git</category>
        
        
      </item>
    
      <item>
        <title>SSL SSH SSO OAuth2.0，理解万岁~</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本博客的第一篇文章，内容四处搜罗，水滴石穿，贵在坚持！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;一句话名词解释&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SSL（Secure Sockets Layer）：其继任者“传输层安全”（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。&lt;/li&gt;
  &lt;li&gt;SSH（Secure Shell）：一种建立在应用层和传输层基础上的安全协议，用于计算机之间的加密登录。&lt;/li&gt;
  &lt;li&gt;SSO（Single Sign On）：单点登录，多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。&lt;/li&gt;
  &lt;li&gt;OAuth2.0：允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;密码学知识&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;加密方法可以分为两大类。一类是单钥加密（private key cryptography），还有一类叫做双钥加密（public key cryptography）。前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是两套密码。&lt;/li&gt;
  &lt;li&gt;在单钥加密的情况下，密钥只有一把，所以密钥的保存变得很重要。一旦密钥泄漏，密码也就被破解。&lt;/li&gt;
  &lt;li&gt;在双钥加密的情况下，密钥有两把，一把是公开的公钥，还有一把是不公开的私钥。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;双钥加密的原理如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;a) 公钥和私钥是一一对应的关系，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立。&lt;/p&gt;

  &lt;p&gt;b) 所有的（公钥, 私钥）对都是不同的。&lt;/p&gt;

  &lt;p&gt;c) 用公钥可以解开私钥加密的信息，反之亦成立。&lt;/p&gt;

  &lt;p&gt;d) 同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;目前，通用的单钥加密算法为DES（Data Encryption Standard），通用的双钥加密算法为&lt;strong&gt;RSA&lt;/strong&gt;（ Rivest-Shamir-Adleman），都产生于上个世纪70年代。&lt;/li&gt;
  &lt;li&gt;在双钥体系中，公钥用来加密信息，私钥用来数字签名。&lt;/li&gt;
  &lt;li&gt;因为任何人都可以生成自己的（公钥，私钥）对，所以为了防止有人散布伪造的公钥骗取信任，就需要一个可靠的第三方机构来生成经过认证的（公钥，私钥）对。目前，世界上最主要的数字服务认证商是位于美国加州的Verisign公司，它的主要业务就是分发RSA数字证书。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;数字签名和数字证书&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;数字签名：消息正文经过Hash后生成摘要，发送者使用&lt;strong&gt;私钥&lt;/strong&gt;对这个摘要进行加密即“数字签名”，然后将数字签名连通正文一并发送。接收者收到后，使用&lt;strong&gt;公钥&lt;/strong&gt;对数字签名进行解密并生成摘要，然后与正文Hash后的结果进行对比，如果一致则安全。&lt;/p&gt;

  &lt;p&gt;数字证书：简单的公钥有可能被替换，从而伪造消息。于是，证书中心（CA，certificate authority）就使用自己的私钥对用户的公钥和一些相关信息进行加密，生成数字证书。发送者将消息正文、数字签名和数字证书一并发送，接收者拿到后用CA的公钥解锁发送者的公钥。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201108/bg2011080913.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;https&quot;&gt;应用数字证书的例子：https协议&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;首先，客户端向服务器发出加密请求&lt;/li&gt;
  &lt;li&gt;服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。&lt;/li&gt;
  &lt;li&gt;客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。&lt;/li&gt;
  &lt;li&gt;如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。&lt;/li&gt;
  &lt;li&gt;如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。&lt;/li&gt;
  &lt;li&gt;如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt; &lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html&quot;&gt;数字签名是什么？&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;ssl&quot;&gt;SSL&lt;/h2&gt;

&lt;h4 id=&quot;section-2&quot;&gt;作用&lt;/h4&gt;

&lt;p&gt;不使用ssl/tls的HTTP通道，就是不加密的通信。所有信息明文传播，带来了三大风险。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;窃听风险（eavesdropping）：第三方可以获知通信内容。&lt;/li&gt;
  &lt;li&gt;篡改风险（tampering）：第三方可以修改通信内容。&lt;/li&gt;
  &lt;li&gt;冒充风险（pretending）：第三方可以冒充他人身份参与通信。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SSL设计的目的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有信息都是加密的，第三方无法窃听&lt;/li&gt;
  &lt;li&gt;具有校验机制，一旦被篡改，通信双方会立刻发现。&lt;/li&gt;
  &lt;li&gt;配备身份证书，防止身份被冒充。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;基本运行过程&lt;/h4&gt;

&lt;p&gt;SSL协议采用公钥加密算法，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。&lt;/p&gt;

&lt;p&gt;两个问题：
&amp;gt; 如何保证公钥不被篡改？解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。
&amp;gt;
&amp;gt; 公钥加密计算量太大，如何减少耗用的时间？解决方法：每一次对话（session），客户端和服务器端都生成一个&lt;strong&gt;“对话密钥”&lt;/strong&gt;（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。&lt;/p&gt;

&lt;p&gt;所以基本过程是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;（1） 客户端向服务器端索要并验证公钥。&lt;/li&gt;
  &lt;li&gt;（2） 双方协商生成”对话密钥”。&lt;/li&gt;
  &lt;li&gt;（3） 双方采用”对话密钥”进行加密通信。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;握手阶段的详细过程&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/201402/bg2014020502.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;客户端发送请求（ClientHello）：发送加密通信请求，内容包括（支持的协议版本、&lt;strong&gt;客户端生成的随机数&lt;/strong&gt;、支持的加密算法、支持的压缩算法）&lt;/li&gt;
  &lt;li&gt;服务器回应（ServerHello）：确认使用的协议版本，&lt;strong&gt;一个服务器生成的随机数&lt;/strong&gt;，确认加密算法，服务器证书&lt;/li&gt;
  &lt;li&gt;客户端回应：首先验证证书，有问题则警告；没问题则从证书中取出服务器公钥，发送一下内容（一个使用该公钥加密的&lt;strong&gt;随机数pre-master-key&lt;/strong&gt;、编码改变通知、客户端握手结束通知）&lt;/li&gt;
  &lt;li&gt;服务器最后回应：使用三个随机数生成“会话密钥”，发送（编码改变通知，服务器握手结束通知）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来客户端和服务器使用http协议通信，使用“会话密钥”加密内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt; &lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&quot;&gt;SSL/TLS协议运行机制的概述&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;ssh&quot;&gt;SSH&lt;/h2&gt;

&lt;h4 id=&quot;ssh-1&quot;&gt;什么是SSH&lt;/h4&gt;

&lt;p&gt;（secure shell）
使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。&lt;/p&gt;

&lt;p&gt;SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。&lt;/p&gt;

&lt;p&gt;好用的客户端：Windows 客户端putty； Mac 客户端zoc&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;最基本的用法&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ssh -p 2222 user@host
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-6&quot;&gt;中间人攻击&lt;/h4&gt;

&lt;p&gt;SSH基本过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;（1）远程主机收到用户的登录请求，把自己的公钥发给用户。&lt;/li&gt;
  &lt;li&gt;（2）用户使用这个公钥，将登录密码加密后，发送回来。&lt;/li&gt;
  &lt;li&gt;（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。所以有可能会产生”中间人攻击”（Man-in-the-middle attack）&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;口令登陆&lt;/h4&gt;

&lt;p&gt;第一次登录对方主机时，系统会提示RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，Are you sure you want to continue connecting (yes/no)?&lt;/p&gt;

&lt;p&gt;当用户决定接受这个远程主机的公钥，host主机就得到认可，要求输入密码。
当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。&lt;/p&gt;

&lt;p&gt;每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。&lt;/p&gt;

&lt;h4 id=&quot;gitssh-key&quot;&gt;公钥登陆（git的ssh key）&lt;/h4&gt;

&lt;p&gt;原理：用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;　$ ssh-keygen // 生成公钥
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。&lt;/p&gt;

&lt;p&gt;将公钥传送到远程主机host上&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ssh-copy-id user@host
// 然后重启远程主机ssh服务
// ubuntu系统
service ssh restart
// debian系统
/etc/init.d/ssh restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt; &lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html&quot;&gt;SSH原理与运用（一）：远程登录&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html&quot;&gt;SSH原理与运用（二）：远程操作与端口转发&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;sso&quot;&gt;SSO&lt;/h2&gt;

&lt;p&gt;单点登录（ Single Sign-On , 简称 SSO ）是目前比较流行的服务于企业业务整合的解决方案之一， SSO使得在多个应用系统中，用户只需要&lt;strong&gt;登录一次&lt;/strong&gt;就可以访问所有相互信任的应用系统。&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;单点登陆的优点&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;工作效率提高：提高员工工作效率，简化应用系统操作过程。&lt;/li&gt;
  &lt;li&gt;增加安全性：强大的身份认证，规避密码安全风险，增加信息系统安全性。&lt;/li&gt;
  &lt;li&gt;降低管理成本：降低管理员工作强度，节省人力投入到更多有意义的IT 建设工作中。&lt;/li&gt;
  &lt;li&gt;实施风险最少：强大的技术支撑，缩短应用部署周期。&lt;/li&gt;
  &lt;li&gt;提高开发人员的效率。SSO 为开发人员提供了一个通用的身份验证框架。实际上，如果 SSO 机制是独立的，那么开发人员就完全不需要为身份验证操心。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-9&quot;&gt;单点登陆的缺点&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;单点故障。在使用单点登录时，所有应用程序使用一个集中的身份验证服务。当集中地身份验证服务发生故障时，将导致所有系统无法登录。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-10&quot;&gt;单点登陆的主要技术&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Cookie：用户登录任意一个受信任的系统后，在当前系统的域名下写入登录令牌的Cookie。&lt;/li&gt;
  &lt;li&gt;Broker-based(基于经纪人)，例如Kerberos等。&lt;/li&gt;
  &lt;li&gt;在一个基于经纪人的SSO解决方案中，有一个集中的认证和用户账号管理的服务器。经纪人给能被用于进一步请求的电子的身份存取。中央数据库的使用减少了管理的代价，并为认证提供一个公共和独立的”第三方”。&lt;/li&gt;
  &lt;li&gt;基于安全断言标记语言(SAML)实现，SAML（Security Assertion Markup Language，安全断言标记语言）的出现大大简化了SSO，并被OASIS批准为SSO的执行标准&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cas&quot;&gt;CAS单点登陆技术&lt;/h4&gt;

&lt;p&gt;CAS（Central Authentication Service）是耶鲁大学开发的单点登录（Single Sign On）系统。CAS应用广泛，具有独立于平台，易于理解，支持代理等功能。&lt;/p&gt;

&lt;p&gt;下面是这个身份验证协议中的主要步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户尝试使用应用程序的 URL 访问应用程序。如果在本地不存在用户登录信息的Cookie，用户将被重定向到 CAS Server登录 URL，采用的是 HTTPS 连接，他请求的应用程序URL作为参数传递。这时CAS Server向用户显示一个用户名/密码对话框。&lt;/li&gt;
  &lt;li&gt;用户输入 ID 和密码，CAS 对他进行身份验证。如果身份验证失败，CAS Server提示失败信息。应用程序并不知道这个用户试图访问它。&lt;/li&gt;
  &lt;li&gt;如果身份验证成功，CAS 就将用户重定向回目标应用程序，并在 URL 中附加一个称为 ticket (Service Ticket,该ticket是由一串随机数产生，用于客户端和应用程序之间的身份验证)的参数，然后，CAS 尝试创建一个称为 ticket-granting cookie 的内存 cookie。这是为了以后进行自动的重新验证；如果存在这个 cookie，就表示这个用户已经成功地登录了，用户就不需要再次输入他的用户名和密码。&lt;/li&gt;
  &lt;li&gt;然后，应用程序要检查这个 ticket 是否正确，以及是否代表一个有效用户；检查的方法是，打开一个 HTTPS 连接来调用 CAS serviceValidate URL，并作为参数传递 ticket 和服务名称。CAS 检查这个 ticket 是否有效，以及是否与请求的服务相关联。如果检查成功，CAS 就将用户名返回给应用程序，并跳转到要访问的应用程序URL。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://static.open-open.com/lib/uploadImg/20150523/20150523193942_202.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt; &lt;a href=&quot;http://www.open-open.com/lib/view/open1432381488005.html&quot;&gt;CAS实现SSO单点登录原理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;拓展&lt;/strong&gt; &lt;a href=&quot;http://blog.csdn.net/javachannel/article/details/752437/&quot;&gt;编写你自己的单点登录（SSO）服务&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;oauth20&quot;&gt;OAuth2.0&lt;/h2&gt;

&lt;p&gt;OAuth是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是2.0版。&lt;/p&gt;

&lt;h4 id=&quot;oauth&quot;&gt;OAuth的思路&lt;/h4&gt;

&lt;p&gt;OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。&lt;/p&gt;

&lt;p&gt;“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。&lt;/p&gt;

&lt;h4 id=&quot;section-11&quot;&gt;运行流程&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/2014/bg2014051203.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;（A）用户打开客户端以后，客户端要求用户给予授权。&lt;/li&gt;
  &lt;li&gt;（B）用户同意给予客户端&lt;strong&gt;授权&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;（C）客户端使用上一步获得的授权，向认证服务器申请令牌。&lt;/li&gt;
  &lt;li&gt;（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。&lt;/li&gt;
  &lt;li&gt;（E）客户端使用令牌，向资源服务器申请获取资源。&lt;/li&gt;
  &lt;li&gt;（F）资源服务器确认令牌无误，同意向客户端开放资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-12&quot;&gt;客户端授权模式&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;授权码模式（authorization code），是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。&lt;/li&gt;
  &lt;li&gt;简化模式（implicit），不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。&lt;/li&gt;
  &lt;li&gt;密码模式（resource owner password credentials），用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。&lt;/li&gt;
  &lt;li&gt;客户端模式（client credentials），指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-13&quot;&gt;更新令牌&lt;/h4&gt;

&lt;p&gt;如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。&lt;/p&gt;

&lt;p&gt;客户端发出更新令牌的HTTP请求，包含以下参数：
granttype：表示使用的授权模式，此处的值固定为”refreshtoken”，必选项。&lt;/p&gt;

&lt;p&gt;refresh_token：表示早前收到的更新令牌，必选项。&lt;/p&gt;

&lt;p&gt;scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt; &lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html&quot;&gt;理解OAuth 2.0&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 21 Apr 2016 23:30:00 +0000</pubDate>
        <link>http://wanglizhi.github.io/2016/04/21/SSH-SSL-SSO-Oauth2.0/</link>
        <guid isPermaLink="true">http://wanglizhi.github.io/2016/04/21/SSH-SSL-SSO-Oauth2.0/</guid>
        
        <category>计算机网络</category>
        
        <category>SSH</category>
        
        <category>SSL</category>
        
        <category>OAuth2.0</category>
        
        <category>HTTPS</category>
        
        <category>名词理解</category>
        
        
      </item>
    
      <item>
        <title>React vs Angular 2：冰与火之歌「译」</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这篇文章转载自&lt;a href=&quot;http://zhuanlan.zhihu.com/FrontendMagazine/20549104&quot;&gt;我在知乎专栏「前端外刊评论」上发表的文章&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://angular.io/&quot;&gt;Angular 2&lt;/a&gt; 已经发布 Beta 版，而且似乎很有信心在 2016 年成为热门框架。是时候进行一场巅峰对决了，我们来看看它如何与 &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; 这个 2015 年的新宠抗衡。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;免责声明：&lt;/strong&gt;我之前很喜欢使用 Angular 1，不过在 2015 年转到了 React。最近我也在 Pluralsight 上发布了一门关于 &lt;a href=&quot;https://www.pluralsight.com/courses/react-flux-building-applications&quot;&gt;React 和 Flux 的课程&lt;/a&gt;（&lt;a href=&quot;http://app.pluralsight.com/signup&quot;&gt;免费试学&lt;/a&gt;）。所以，&lt;strong&gt;是的，我本人是有偏见的，但我不会偏袒任何一方。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;好了，我们开始吧，这场对决将会非常血腥。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*MRPl_SNuRGJchb6eOAnkSA.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图片来源：&lt;a href=&quot;https://twitter.com/jwcarroll&quot;&gt;@jwcarrol&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;两者根本不具有可比性！&lt;/h2&gt;

&lt;p&gt;是的是的，Angular 是框架，React 是类库。所以有人觉得比较这两者没有逻辑性可言。大错特错！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;选择 Angular 还是 React 就像选择直接购买成品电脑还是买零件自己组装一样。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;两者的优缺点本文都会提及，我会拿 React 语法和组件模型跟 Angular 的语法和组件模型做对比。这就像是拿成品电脑的 CPU 跟零售的 CPU 做对比，没有任何不妥。&lt;/p&gt;

&lt;h2 id=&quot;angular-2-&quot;&gt;Angular 2 的优点&lt;/h2&gt;

&lt;p&gt;我们先看 Angular 相对 React 有哪些优势。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;&lt;strong&gt;无选择性疲劳&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;Angular 是一个完整的框架，本身就提供了比 React 多得多的建议和功能。而要用 React，开发者通常还需要借助别的类库来打造一个真正的应用。比如你可能需要额外的库来处理路由、强制单向数据流、进行 API 调用、做测试以及管理依赖等等。要做的选择和决定太多了，让人很有压力。这也是为什么 React 有那么多的入门套件的原因（我自己就写了两个：&lt;a href=&quot;https://github.com/coryhouse/react-flux-starter-kit&quot;&gt;1&lt;/a&gt;、&lt;a href=&quot;https://github.com/coryhouse/react-slingshot&quot;&gt;2&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;Angular 自带了不少主张，所以能够帮助你更快开始，不至于因为要做很多决定而无所适从。这种强制的一致性也能帮助新人更快适应其开发模式，并使得开发者在不同团队间切换更具可行性。&lt;/p&gt;

&lt;p&gt;Angular 核心团队让我非常欣赏的一点是，他们拥抱了 TypeScript，这就造成了另一个优势。&lt;/p&gt;

&lt;h4 id=&quot;typescript--&quot;&gt;TypeScript = 阳关大道&lt;/h4&gt;

&lt;p&gt;没错，并非所有人都喜欢 TypeScript，但是 Angular 2 毅然决然地选择了它确实是个巨大的优势。反观 React，网上的各种示例应用令人沮丧地不一致——ES5 和 ES6 的项目基本上各占一半，而且目前存在&lt;a href=&quot;http://jamesknelson.com/should-i-use-react-createclass-es6-classes-or-stateless-functional-components/&quot;&gt;三种不同的组件声明方式&lt;/a&gt;。这无疑给初学者造成了困惑。（Angular 还拥抱了装饰器（decorator）而不是继承（extends）——很多人认为这也是个加分项）。&lt;/p&gt;

&lt;p&gt;尽管 Angular 2 并不强制使用 TypeScript，但显然的是，Angular 的核心团队默认在文档中使用 TypeScript。这意味着相关的示例应用和开源项目更有可能保持一致性。Angular 已经提供了&lt;a href=&quot;https://angular.io/docs/ts/latest/quickstart.html&quot;&gt;非常清晰的关于如何使用 TypeScript 编译器的例子&lt;/a&gt;。（诚然，目前&lt;a href=&quot;http://angularjs.blogspot.com/2015/09/angular-2-survey-results.html&quot;&gt;并非所有人都在拥抱 TypeScript&lt;/a&gt;，但我有理由相信等到正式发布之后，TypeScript 会成为事实上的标准）。这种一致性应该会帮助初学者避免在学习 React 时遇到的疑惑和选择困难。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;极少的代码变动&lt;/h4&gt;

&lt;p&gt;2015 年是 &lt;a href=&quot;https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.559iqxb39&quot;&gt;JavaScript 疲劳&lt;/a&gt;元年，React 可以说是罪魁祸首。而且 React 尚未发布 1.0，所以未来还可能有很多变数。React 生态圈依旧在快速地变动着，尤其是&lt;a href=&quot;https://github.com/kriasoft/react-starter-kit/issues/22&quot;&gt;各种 Flux 变种&lt;/a&gt;和&lt;a href=&quot;https://github.com/rackt/react-router&quot;&gt;路由&lt;/a&gt;。也就是说，你今天用 React 写的所有东西，都有可能在 React 1.0 正式发布后过时，或者必须进行大量的改动。&lt;/p&gt;

&lt;p&gt;相反，Angular 2 是一个对已经成熟完整框架（Angular 1）的重新发明，而且经过仔细、系统的设计。所以 Angular 不大可能在正式发布后要求已有项目进行痛苦的代码变动。Angular 作为一个完整的框架，你在选择它的时候，也会信任其开发团队，相信他们会认真决定框架的未来。而使用 React，一切都需要你自己负责，你要自己整合一大堆开源类库来打造一个完整的应用，类库之间互不相干且变动频繁。这是一个令人沮丧的耗时工作，而且永远没有尽头。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;&lt;strong&gt;广泛的工具支持&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;后面我会说，我认为 React 的 JSX 是非常耀眼的亮点。然而要使用 JSX，你需要选择支持它的工具。尽管 React 已经足够流行，工具支持不再是什么问题，但诸如 IDE 和 lint 工具等新工具还不大可能很快得到支持。Angular 2 的模版是保存在一个字符串或独立的 HTML 文件中的，所以不要求特殊的工具支持（不过似乎 Angular 字符串模版的智能解析工具已经呼之欲出了）。&lt;/p&gt;

&lt;h4 id=&quot;web-components-&quot;&gt;Web Components 友好&lt;/h4&gt;

&lt;p&gt;Angular 2 还拥抱了 Web Component 标准。唉，真尴尬我居然一开始忘记提到这点了——最近我还发布了一门关于&lt;a href=&quot;https://www.pluralsight.com/courses/web-components-shadow-dom&quot;&gt;Web Components 课程&lt;/a&gt;呢！简单来说，把 Angular 2 组件转换成原生 Web Components 应该会比 React 组件容易得多。固然 Web Components 的&lt;a href=&quot;http://jonrimmer.github.io/are-we-componentized-yet/&quot;&gt;浏览器支持度依然很弱&lt;/a&gt;，但长期来看，对 Web Components 友好是很大的优势。&lt;/p&gt;

&lt;p&gt;Angular 的实现有其自身的局限和陷阱，这正好让我过渡到对 React 优势的讨论。&lt;/p&gt;

&lt;h3 id=&quot;react-&quot;&gt;React 的优点&lt;/h3&gt;

&lt;p&gt;现在，让我们看看是什么让 React 如此与众不同。&lt;/p&gt;

&lt;h4 id=&quot;jsx&quot;&gt;&lt;strong&gt;JSX&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;JSX 是一种类似 HTML 的语法，但它实际上会被编译成 JavaScript。将标签与代码混写在同一个文件中意味着输入一个组件的函数或者变量时你将享受到自动补全的福利。而 Angular 基于字符串的模版就相形见绌了：很多编辑器都不会高亮它们（只会显示单色）、只有有限的代码补全支持，并且一直到运行时才会报错。并且，通常你也只能得到很有限的错误提示。不过，Angular 的团队&lt;a href=&quot;https://github.com/angular/angular/issues/4417&quot;&gt;造了一个自己的 HTML 解析器来解决这个问题&lt;/a&gt;。（叼叼叼！）&lt;/p&gt;

&lt;p&gt;如果你不喜欢 Angular 的字符串模版，你可以把模版移到一个单独的文件里去。不过这样你就回到了我认为的“老样子”：你需要在自己脑袋里记住这两个文件的关联，不但没有代码自动补全，也没有任何编译时检查来协助你。这听起来可能并不算什么……除非你已经爱上了与 React 相伴的日子。在同一个文件中组合组件还能享受编译时的检查，大概是 JSX 最与众不同的地方之一了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://p5.qhimg.com/d/inn/8a99f370/2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对比 Angular 2 与 React 在标签忘记闭合时是如何表现的。&lt;/p&gt;

&lt;p&gt;关于为什么 JSX 是一个巨大的优势，可以看看 &lt;a href=&quot;https://medium.com/@housecor/react-s-jsx-the-other-side-of-the-coin-2ace7ab62b98#.5007n49wq&quot;&gt;JSX：硬币的另一面（JSX: The Other Side of the Coin）&lt;/a&gt;. （P.S. 这是作者写的另一篇文章，如果大家希望我们可以把这篇也翻了，欢迎在评论区举手）&lt;/p&gt;

&lt;h4 id=&quot;react--1&quot;&gt;React 报错清晰快速&lt;/h4&gt;

&lt;p&gt;当你在 React 的 JSX 中不小心手抖打错时，它并不会被编译。这是一件非常美妙的事情：无论你是忘记闭合了标签还是引用了一个不存在的属性（property），你都可以立刻知道到底是哪一行出错了。&lt;strong&gt;JSX 编译器会指出你手抖的具体行号&lt;/strong&gt;，彻彻底底加速你的开发。&lt;/p&gt;

&lt;p&gt;相反，当你在 Angular 2 中不小心敲错了一个变量时，鸦雀无声。&lt;strong&gt;Angular 2 并不会在编译时做什么，它会等到运行时才静默报错。&lt;/strong&gt;它报错得&lt;em&gt;如此之慢&lt;/em&gt;，我加载完整个应用然后奇怪为什么我的数据没有显示出来呢？这太不爽了。&lt;/p&gt;

&lt;h4 id=&quot;react--javascript-&quot;&gt;React 以 JavaScript 为中心&lt;/h4&gt;

&lt;p&gt;终于来了。这才是 React 和 Angular 的根本区别。&lt;strong&gt;很不幸，Angular 2 仍然是以 HTML 而非 JavaScript 为中心的。&lt;/strong&gt;Angular 2 并没有解决它设计上的根本问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Angular 2 继续把 “JS” 放到 HTML 里。React 则把 “HTML” 放到 JS 里。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种分歧带来的影响真是再怎么强调也不为过。它们从根本上影响着开发体验。Angular 以 HTML 为中心的设计留下了巨大的缺陷。正如我在 &lt;a href=&quot;https://medium.com/@housecor/react-s-jsx-the-other-side-of-the-coin-2ace7ab62b98#.jqh5kkxlk&quot;&gt;JSX：硬币的另一面&lt;/a&gt; 中所说的，JavaScript 远比 HTML 要强大。因此，&lt;strong&gt;增强 JavaScript 让其支持标签要比增强 HTML 让其支持逻辑要合理得多&lt;/strong&gt;。无论如何，HTML 与 JavaScript 都需要某种方式以粘合在一起。React 以 JavaScript 为中心的思路从根本上优于 Angular、Ember、Knockout 这些以 HTML 为中心的思路。&lt;/p&gt;

&lt;p&gt;让我们来看看为什么。&lt;/p&gt;

&lt;h4 id=&quot;react--javascript---&quot;&gt;React 以 JavaScript 为中心的设计 = 简约&lt;/h4&gt;

&lt;p&gt;Angular 2 延续了 Angular 1 试图让 HTML 更加强大的老路子。所以即使是像循环或者条件判断这样的简单任务你也不得不使用 Angular 2 的独特语法来完成。例如，Angular 2 通过两种语法同时提供了单向数据绑定与双向数据绑定，可不幸的是它们实在差得有点多：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;{{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;myVar&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}}&lt;/span&gt;        //单向数据绑定
ngModel=&quot;myVar&quot;  //双向数据绑定
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在 React 中，数据绑定语法不取决于数据流的单双向（数据绑定的单双向是在其他地方处理的，不得不说我觉得理应如此）。不管是单向还是双向数据流，绑定语法都是这样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;myVar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Angular 2 的内联母版（inline master templates）使用了这样的语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ngFor=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;#hero of heroes&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;{{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;hero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}}&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这个代码片段遍历了一组 hero，而我比较关心的几点是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过星号来声明一个“母版”实在是太晦涩了&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hero&lt;/code&gt; 前的英镑符号（&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;）用于声明一个局部模版变量。这个概念感觉非常鸡肋（如果你偏好不使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;，你也可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;var-&lt;/code&gt; 前缀写法）&lt;/li&gt;
  &lt;li&gt;为 HTML 加入了循环语义的HTML 特性（attribute）&lt;code class=&quot;highlighter-rouge&quot;&gt;ngFor&lt;/code&gt; 是 Angular 特有的东西&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相比上面 Angular 2 的语法，React 的语法可是纯净的 JavaScript （不过我得承认下面的属性 &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt; 是个 React 的私货）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
  { heroes.map(hero =&amp;gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;key=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;{hero.id}&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;{hero.name}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
  )}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;鉴于 JS 原生支持循环，React JSX 利用 JS 的力量来做到这类事情简直易如反掌，配合 &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt; 能做的还远不止此。&lt;/p&gt;

&lt;p&gt;去看看 &lt;a href=&quot;https://angular.io/docs/ts/latest/guide/cheatsheet.html&quot;&gt;Angular 2 速查表&lt;/a&gt;？那不是 HTML，也不是 JavaScript……这叫 &lt;strong&gt;Angular&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;读懂 Angular：&lt;/strong&gt; 学一大堆 Angular 特有的语法&lt;/p&gt;

  &lt;p&gt;读懂 React： 学 JavaScript&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;React 因为语法和概念的简约而与众不同。我们不妨品味下当今流行的 JS 框架/库都是如何实现遍历的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ember     : 
Angular 1 : ng-repeat
Angular 2 : ngFor
Knockout  : data-bind=&quot;foreach&quot;
React     : 直接用 JS 就好啦 :)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了 React，所有其它框架都用自己的专有语法重新发明了一个我们在 JavaScript 常见得不能再常见的东西：&lt;strong&gt;循环&lt;/strong&gt;。这大概就是 React 的美妙之处，利用 JavaScript 的力量来处理标签，而不是什么奇怪的新语法。&lt;/p&gt;

&lt;p&gt;Angular 2 中的奇怪语法还有点击事件的绑定：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;onSelect(hero)&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相反，React 再一次使用了普通的 JavaScript：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onSelect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并且，鉴于 React 内建了一个模拟的事件机制（Angular 2 也有），你并不需要去担心使用内联语法声明事件处理器所暗含的性能问题。&lt;/p&gt;

&lt;p&gt;为什么要强迫自己满脑子都是一个框架的特殊语法呢？为什么不直接拥抱 JS 的力量？&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;奢华的开发体验&lt;/h4&gt;

&lt;p&gt;JSX 具备的代码自动补全、编译时检查与丰富的错误提示已经创造了非常棒的开发体验，既为我们减少了输入，与节约了时间。而配合上热替换（hot reloading）与时间旅行（time travel），你将获得前所未有的开发体验，效率高到飞起。&lt;/p&gt;

&lt;p&gt;原文这里链了个 Youtube 上的视频：&lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&amp;amp;feature=youtu.be&quot;&gt;Dan Abramov - Live React: Hot Reloading with Time Travel at react-europe 2015&lt;/a&gt;，大家自备梯子。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;担心框架的大小？&lt;/h4&gt;

&lt;p&gt;这里是一些常见框架/库压缩后的大小（&lt;a href=&quot;https://gist.github.com/Restuta/cda69e50a853aa64912d&quot;&gt;来源&lt;/a&gt;）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Angular 2:&lt;/strong&gt; 566k (766k with RxJS)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Ember:&lt;/strong&gt; 435k&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.4.8/angular.min.js&quot;&gt;&lt;strong&gt;Angular 1&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; 143k&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;React + Redux:&lt;/strong&gt; 139k&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;列出的都是框架级的、用于浏览器且压缩后的大小（但并未 gzip）。需要补充的是，Angular 2 的尺寸在最终版本发布时应该会有所减小。&lt;/p&gt;

&lt;p&gt;为了做一个更真实的对比，我将 Angular 2 &lt;a href=&quot;https://angular.io/docs/ts/latest/tutorial/&quot;&gt;官方教程&lt;/a&gt;中的 Tour of Heroes 应用用 Angular 2 和 React（还用上了新的 &lt;a href=&quot;https://github.com/coryhouse/react-slingshot&quot;&gt;React Slingshot&lt;/a&gt; 入门套件）都实现了一遍，结果如何呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/coryhouse/angular-2-tour-of-heroes/tree/master&quot;&gt;&lt;strong&gt;Angular 2&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; 764k 压缩后&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/coryhouse/react-tour-of-heroes&quot;&gt;&lt;strong&gt;React + Redux&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;:&lt;/strong&gt; 151k 压缩后&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到，&lt;strong&gt;做一个差不多的东西，Angular 2 目前的尺寸是 React + Redux 的五倍还多&lt;/strong&gt;。重要的事情再说一遍，Angular 2 的最终版本应该会减重。&lt;/p&gt;

&lt;p&gt;不过，我承认关于框架大小的担忧可能被夸大了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;大型应用往往至少有几百 KB 的代码，经常还更多，不管它们是不是使用了框架。开发者需要做很多的抽象来构建一个复杂的软件。无论这些抽象是来自框架的还是自己手写的，它都会对应用的加载性能造成负面影响。&lt;/p&gt;

  &lt;p&gt;就算你完全杜绝框架的使用，许多应用仍然是几百 KB 的 JavaScript 在那。 — Tom Dale &lt;a href=&quot;http://tomdale.net/2015/11/javascript-frameworks-and-mobile-performance/&quot;&gt;JavaScript Frameworks and Mobile Performance&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tom 的观点是对的。像 Angular、Ember 这样的框架之所以更大是因为它们自带了更多的功能。&lt;/p&gt;

&lt;p&gt;但是，我关心的点在于：很多应用其实用不到这种大型框架提供的所有功能。在这个越来越拥抱微服务、微应用、&lt;a href=&quot;http://www.npmjs.com&quot;&gt;单一职责模块（single-responsibility packages）&lt;/a&gt;的时代，&lt;strong&gt;React 通过让你自己挑选必要模块，让你的应用大小真正做到量身定做&lt;/strong&gt;。在这个有着 200,000 个 npm 模块的世界里，这点非常强大。&lt;/p&gt;

&lt;h4 id=&quot;react-unix-httpsenwikipediaorgwikiunixphilosophy&quot;&gt;React 信奉&lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_philosophy&quot;&gt;Unix 哲学&lt;/a&gt;.&lt;/h4&gt;

&lt;p&gt;React 是一个类库。它的哲学与 Angular、Ember 这些大而全的框架恰恰相反。你可以根据场景挑选各种时髦的类库，搭配出你的最佳组合。JavaScript 世界在飞速发展，React 允许你不断用更好的类库去迭代你应用中的每个小部分，而不是傻等着你选择的框架自己升级。&lt;/p&gt;

&lt;p&gt;Unix 久经沙场屹立不倒，原因就是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;小而美、可组合、目的单一，这种哲学永远不会过时。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;React 作为一个专注、可组合并且目的单一的工具，已经被&lt;a href=&quot;https://github.com/facebook/react/wiki/Sites-Using-React&quot;&gt;全世界的各大网站们&lt;/a&gt;使用，预示着它的前途光明（当然，Angular 也被用于&lt;a href=&quot;https://www.madewithangular.com/#/&quot;&gt;许多大牌网站&lt;/a&gt;）。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;谢幕之战&lt;/h4&gt;

&lt;p&gt;Angular 2 相比第一代有着长足的进步。新的组件模型比第一代的指令（directives）易学许多；新增了对于同构／服务器端渲染的支持；使用虚拟 DOM 提供了 3-10 倍的性能提升。这些改进使得 Angular 2 与 React 旗鼓相当。不可否认，它功能齐全、观点鲜明，能够显著减少 “JavaScript 疲劳” 。&lt;/p&gt;

&lt;p&gt;不过，Angular 2 的大小和语法都让我望而却步。Angular 致力的 HTML 中心设计比 React 的 JavaScript 中心模型要复杂太多。在 React 中，你并不需要学习 &lt;code class=&quot;highlighter-rouge&quot;&gt;ng-什么什么&lt;/code&gt; 这种框架特有的 HTML 补丁（shim），你只要写 JavaScript 就好了。这才是我相信的未来。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;著作权声明&lt;/h3&gt;

&lt;p&gt;本文译自 &lt;a href=&quot;https://medium.freecodecamp.com/angular-2-versus-react-there-will-be-blood-66595faafd51#.v4y4euy1r&quot;&gt;Angular 2 versus React: There Will Be Blood&lt;/a&gt;，其实&lt;a href=&quot;http://www.w3ctech.com/topic/1675?from=timeline&amp;amp;isappinstalled=0&quot;&gt;之前有人翻译过&lt;/a&gt;，但是翻得水平有一点不忍直视，我们不希望浪费这篇好文章。&lt;br /&gt;
本文由 &lt;a href=&quot;https://www.zhihu.com/people/li-ling-hao&quot;&gt;@李凌豪&lt;/a&gt; &lt;a href=&quot;https://www.zhihu.com/people/huxpro&quot;&gt;@黄玄&lt;/a&gt; 联合翻译，首次发布于&lt;a href=&quot;http://zhuanlan.zhihu.com/FrontendMagazine&quot;&gt;前端外刊评论 · 知乎专栏&lt;/a&gt;，转载请保留原文链接 ;)&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Feb 2016 12:00:00 +0000</pubDate>
        <link>http://wanglizhi.github.io/2016/02/01/React-vs-Angular2/</link>
        <guid isPermaLink="true">http://wanglizhi.github.io/2016/02/01/React-vs-Angular2/</guid>
        
        <category>前端开发</category>
        
        <category>JavaScript</category>
        
        <category>译文</category>
        
        
      </item>
    
      <item>
        <title>聊聊「阿里旅行 · 去啊」—— 行业与战略 </title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本篇为该系列第一篇 —— 行业与战略，让我们聊聊行业、战略与格局。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;近几年，互联网产品从线上斗到了线下，互联网行业和传统行业的跨界融合屡见不鲜，“渗透传统行业”几乎成为了全行业下一轮创新的标配，新词“互联网+”也应运而生：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;将互联网行业的生产要素，深度融入经济、社会等各个领域，尝试改变一些传统的实体经济行业，创造出新的产品形态、商业模式和生态&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;O2O 领域已经有了非常多成功的案例：从最早的千团大战，到前年打车大战，再到餐饮 O2O……传统行业被撬动的同时，无数新的市场也在被发掘：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;金融： 蚂蚁金服、芝麻信用、京东白条&lt;/li&gt;
  &lt;li&gt;通信： 微信电话本，阿里通信&lt;/li&gt;
  &lt;li&gt;交通： 打车、租车、专车&lt;/li&gt;
  &lt;li&gt;地产： 二手房、租房&lt;/li&gt;
  &lt;li&gt;医疗、家电、教育、票务……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，还有我们的在线旅游行业，BAT 纷纷入局，盛况空前。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;历史总是现在与未来的明鉴，&lt;strong&gt;垂直领域互联网产品&lt;/strong&gt;更是与行业的历史紧密相连。想要用互联网产品解决传统行业的问题，就得先了解这个行业的发展规律，看看这个行业都经历过怎样的变革。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;传统老大：旅行社&lt;/h3&gt;

&lt;p&gt;旅行社，一个耳熟能详的名字。在互联网的变革到来之前，旅游行业几乎就是旅行社的天下。&lt;/p&gt;

&lt;p&gt;在行业术语里，旅行社被称为 &lt;strong&gt;TA：Travel Agency —— 旅游代理&lt;/strong&gt;。
旅行社为你提供旅游信息，代理你办航班，定酒店，买门票，办签证，找导游。通过代理你的旅游消费行为，TA 从中获利。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-alitrip-pd/post-alitrip-pd.013.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;ota&quot;&gt;第一轮革命：兴起的电商与 OTA&lt;/h3&gt;

&lt;p&gt;1995 年，中国互联网沸腾元年，北京上海接入 Internet 节点。
1998 年，中国互联网电商元年，第一笔在线交易产生。
1999 年，马云的阿里巴巴创办。同年，旅游行业未来的两大巨头，&lt;strong&gt;携程&lt;/strong&gt;、&lt;strong&gt;艺龙&lt;/strong&gt; 双双出世。&lt;/p&gt;

&lt;p&gt;携程、艺龙利用互联网的体验优势，迅速占领了 TA 的市场，它们被称作 &lt;strong&gt;OTA：Online Travel Agency&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-alitrip-pd/post-alitrip-pd.014.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在他们诞生之初，其实都叫 XX旅行网。那为什么不说他们是做网站的，而说他们是做 TA 的呢？&lt;/p&gt;

&lt;p&gt;这叫要引出本文涉及的第一个常见商业模式：&lt;/p&gt;

&lt;h4 id=&quot;agency-&quot;&gt;Agency 模式&lt;/h4&gt;

&lt;p&gt;Agency，即&lt;strong&gt;代理模式&lt;/strong&gt;。通过代理用户的消费行为，代理商就可以靠佣金的方式从中获利。
举个例子：假设携程旅行网今天给某某酒店拉来了 100 个日间，那么这个酒店就要以 30元/日间 的方式给携程旅行网反多少的红利。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;佣金，说白了，就是中介费。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-alitrip-pd/post-alitrip-pd.016.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;了解了 Agency 模式，我们再回过来看携程、艺龙：
虽然渠道改成了互联网，但其商业模式还是 TA 的那套玩法，它们其实是在和传统 TA 分同一块蛋糕。
还是咨询、酒店、机票、旅游团、旅游套餐，只是&lt;strong&gt;你们在线下玩，我去线上玩了&lt;/strong&gt;，我有渠道优势。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;第二轮革命：比价搜索与去哪儿&lt;/h3&gt;

&lt;p&gt;时光飞驰到 2005 年，单纯做线下已经满足不了很多传统 TA 们了，大家纷纷向携程、艺龙学习，进攻线上，转型 OTA 。&lt;/p&gt;

&lt;p&gt;就在这样的格局下，&lt;strong&gt;去哪儿&lt;/strong&gt; 横空出世，一下占据了半壁江山：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-alitrip-pd/post-alitrip-pd.021.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;去哪儿做了一件什么事呢，它把这些 OTA 的数据全都爬过来，做了一个&lt;strong&gt;比价平台&lt;/strong&gt;。这样，用户就可以在去哪儿的网站上看看哪家 OTA 更便宜，然后用户就去消费哪家的服务。&lt;/p&gt;

&lt;p&gt;所谓“比价平台”，本质上说，就是 &lt;strong&gt;Search Engine —— 搜索引擎&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-alitrip-pd/post-alitrip-pd.018.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个这个玩法一下就厉害了：
&lt;strong&gt;去哪儿挡在了用户和所有 OTA 之间，OTA 还是做原来的事情，而去哪儿则拿下了用户找 OTA 的过程&lt;/strong&gt;。同是搜索引擎的百度也是如此：百度自己并不生产内容，而是拿下了用户找内容的过程。&lt;/p&gt;

&lt;p&gt;Let’s why search engine awesome：因为用户在互联网的信息海洋上找信息太难了，所以用户必须要靠搜索引擎来解决这个痛点，而搜索引擎自己也就成为了渠道：&lt;/p&gt;

&lt;h4 id=&quot;channel-&quot;&gt;Channel 模式&lt;/h4&gt;

&lt;p&gt;Channel，即&lt;strong&gt;渠道模式&lt;/strong&gt;。通过优化用户的体验路径，在用户和 B 方之前挡了一道，主要对 B 盈利。
最常见的对 B 盈利方式就是广告：&lt;strong&gt;Pay for Performance&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-alitrip-pd/post-alitrip-pd.019.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;简单看一眼携程和去哪儿的收入占比就可以发现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;携程主要靠来自酒店、机票的佣金盈利&lt;/li&gt;
  &lt;li&gt;去哪儿则主要靠 PFP 广告盈利&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-alitrip-pd/post-alitrip-pd.020.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过去哪儿的比价平台，小 OTA 开始有机会通过价格战和大 OTA 周旋。去哪儿在给予了小 OTA 机会的同时也造就了自己，这和 2003 年淘宝 C2C 的崛起，颇有异曲同工之意。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;第 2.5 轮革命：尴尬的淘宝旅行&lt;/h3&gt;

&lt;p&gt;为什么说淘宝旅行是 2.5 次革命呢，因为它想革，但没革上。
为什么没有革上呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先是切入时机太晚&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;阿里其实 2010 年就开始做淘宝旅行了，一直划分在淘宝网下，由那时的淘宝北研（淘宝 UED 北京研发）团队负责，这个团队吸纳了大批雅虎中国的精英，技术水平相当高。&lt;br /&gt;
可是 2010 年才切入这个市场实在是太晚了，携程、去哪儿的口碑和用户习惯早都养成好几年了，没人会去你淘宝上搜航班酒店，你有大入口也没有用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二是资源倾斜不足&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2010 年还没有什么 &lt;strong&gt;互联网+&lt;/strong&gt; 的概念，结合传统行业也还没有现在这么热，淘宝做旅游这事用了多大力气推很难说，反正我是没听过。
阿里同年的发展重心还是在其电商体系的完善上：&lt;strong&gt;淘宝商城&lt;/strong&gt; 启用独立域名，其 B2C 的模式刚好弥补了淘宝 C2C 的问题，这货就是后来的&lt;strong&gt;天猫&lt;/strong&gt;，我们可以比较一下两者在资源倾斜上的差异：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;BU&lt;/th&gt;
      &lt;th&gt;2008&lt;/th&gt;
      &lt;th&gt;2010&lt;/th&gt;
      &lt;th&gt;2011&lt;/th&gt;
      &lt;th&gt;2012&lt;/th&gt;
      &lt;th&gt;2013&lt;/th&gt;
      &lt;th&gt;2014&lt;/th&gt;
      &lt;th&gt;2015&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;天猫&lt;/td&gt;
      &lt;td&gt;淘宝商城&lt;/td&gt;
      &lt;td&gt;独立域名&lt;/td&gt;
      &lt;td&gt;分拆&lt;/td&gt;
      &lt;td&gt;更名天猫&lt;br /&gt;天猫事业部（1/7）&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;去啊&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;淘宝旅行&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;航旅事业部（1/25）&lt;/td&gt;
      &lt;td&gt;分拆&lt;br /&gt;更名去啊&lt;/td&gt;
      &lt;td&gt;独立域名&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;三是思路问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;淘宝旅行想怎么玩呢，它实际上就是想用淘宝/天猫的思路去做在线旅行，其实背后还是淘宝卖家和天猫卖家，只不过这次的商户换成 OTA 入驻了，然后大家开开心心像卖衣服一样去卖旅行产品。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-alitrip-pd/post-alitrip-pd.023.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;听上去很美，不但利用了阿里系的大量资源，还直接复刻了淘宝/天猫的牛逼模式 —— 平台模式&lt;/p&gt;

&lt;h4 id=&quot;platform-&quot;&gt;Platform 模式&lt;/h4&gt;

&lt;p&gt;Platform，即&lt;strong&gt;平台模式&lt;/strong&gt;，可以说是当今最叼的商业模式了，它相当于构建了一个完整的生态、市场环境，在这里整合买卖双方的资源。通过维护市场秩序、制定市场规则，让市场活跃，从而赚取场子费。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-alitrip-pd/post-alitrip-pd.026.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;想想看，每一笔交易都在你的地盘上发生，只要市场一直活跃，你就可以在其中&lt;strong&gt;双边、多边盈利&lt;/strong&gt;。什么竞价排名、广告平台、VIP 特权，盈利模式太丰富了&lt;/p&gt;

&lt;p&gt;美梦做完了，回到淘宝旅行来。做平台是每个产品的梦想，肯定是对的。那么问题出在哪呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;太不垂直了！&lt;/strong&gt; 旅游行业，极度要求信誉：去哪儿对接的都是 B 类商家（OTA，品牌连锁酒店，直销等），从根本上就保证了产品体验。淘宝旅行的产品则充斥着大量的小旅行社、个人之类的小卖家，严重影响购买体验。你能想象预定一间酒店发现下面十几二十页的卖家，选完卖家又要跟人在旺旺上扯半个小时么？价格便宜作为唯一的优势，是以严重牺牲产品购买体验为代价的，极为得不偿失。更何况，旅游产品的受众大部分还是消费能力较强的人群，更是看重商家/产品质量而不是价格了。&lt;/p&gt;

&lt;h3 id=&quot;now&quot;&gt;第三轮革命：Now&lt;/h3&gt;

&lt;p&gt;OK，经过这么一番折腾，第三次变革就来了。
BAT 纷纷介入，行业进入了传说中的 BATX 格局：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-alitrip-pd/post-alitrip-pd.028.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;阿里最近动作频频，力推去啊不说，更是收购线下酒店软件石基，配合蚂蚁金服期下芝麻信用开展“酒店信用住”等业务
百度早早投资去哪儿，两个搜索引擎起家的公司风格一脉相承。同时，百度也悄悄发布了百度旅行这样的试水产品
腾讯入股艺龙，同程网等，也在尝试 QQ 旅游等产品&lt;/p&gt;

&lt;p&gt;Update：不过，就在 2015.5 左右，携程宣布收购艺龙，非常戏剧性的局面啊……&lt;/p&gt;

&lt;p&gt;为什么都要介入呢？
一是互联网结合传统行业的大潮到来，大家都发现旅游行业是一个金矿，市场其实特别大……
二是这个领域确实还有很多可以突破的商业模式存在，很多细分领域都开始有创业公司起来，整个行业的生态也越来越丰富：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-alitrip-pd/post-alitrip-pd.029.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种时候，BAT 这样的土豪公司就想进来收网了 —— 砸钱也得砸出个平台来！
所以，这一轮游戏一定能看到一次大洗牌（艺龙第一个就阵亡了）&lt;/p&gt;

&lt;p&gt;那么，这轮革命怎么演变呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一是模式融合&lt;/strong&gt;，以前做 OTA 的做 OTA，做渠道的做渠道，尝试做平台的做平台。现在，大家都知道平台模式可能是更好的形态，纷纷开始进化了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;都做 OTA，拿下各种牛逼直营，最典型的就是航班&lt;/li&gt;
  &lt;li&gt;都做平台，尤其是质量相对比较高的 B2C 平台。然后尝试可能的 C2C 产品形态 （去啊的客栈是一个很好的尝试）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-alitrip-pd/post-alitrip-pd.030.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二是思路进化&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从单一的购买/渠道业务转向服务平台。融合周边服务，拉上细分领域，外围行业一起玩&lt;/li&gt;
  &lt;li&gt;强调用户体验与用户留存，强调&lt;strong&gt;一站式服务&lt;/strong&gt;、&lt;strong&gt;个性化服务&lt;/strong&gt; 等更极致的产品形态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-alitrip-pd/post-alitrip-pd.031.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而这些演变，正是 &lt;strong&gt;阿里旅行 · 去啊&lt;/strong&gt; 致力去做到的。从大版本 5.0 开始，淘宝旅行将 &lt;strong&gt;洗心革面&lt;/strong&gt;，去追求一个更极致，更垂直，体验更优秀的产品形态。&lt;/p&gt;

&lt;p&gt;让我们一起见证去啊的成长，与在线旅游行业的变革吧！&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;本篇完。&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;本文作者系前「阿里旅行 · 去啊」前端实习生，本文系业余时间学习之作。
如有任何知识产权、版权问题或理论错误，还请指正。
转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 15 Jun 2015 00:00:00 +0000</pubDate>
        <link>http://wanglizhi.github.io/2015/06/15/alitrip-strategy/</link>
        <guid isPermaLink="true">http://wanglizhi.github.io/2015/06/15/alitrip-strategy/</guid>
        
        <category>产品设计</category>
        
        <category>阿里巴巴</category>
        
        <category>在线旅行</category>
        
        <category>电子商务</category>
        
        
      </item>
    
      <item>
        <title>Unix/Linux 扫盲笔记</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;This document is not completed and will be updated anytime.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;unix&quot;&gt;Unix&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unix is a &lt;strong&gt;family&lt;/strong&gt; of multitasking, multiuser computer OS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Derive from the original &lt;strong&gt;AT&amp;amp;T Unix&lt;/strong&gt;, Developed in the 1970s at &lt;strong&gt;Bell Labs&lt;/strong&gt; (贝尔实验室), initially intended for use inside the &lt;strong&gt;Bell System&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;bell-labs&quot;&gt;Bell Labs&lt;/h4&gt;
    &lt;p&gt;Bell 和 AT&amp;amp;A 在那时已经是一家了，可以看到那时的通信公司真是一线 IT 公司呢。 
&lt;strong&gt;C 语言也是 Bell Labs 的产物&lt;/strong&gt;，从一开始就是为了用于 Unix 而设计出来的。所以 Unix （在 73 年用 C 重写）在高校流行后，C 语言也获得了广泛支持。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AT&amp;amp;T licensed Unix to outside parties(第三方) from the late 1970s, leading to a variety of both &lt;strong&gt;academic&lt;/strong&gt; (最有有名的 BSD ) and &lt;strong&gt;commercial&lt;/strong&gt; (Microsoft Xenix, IBM AIX, SunOS Solaris)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;xenix&quot;&gt;Xenix&lt;/h4&gt;
    &lt;p&gt;微软 1979 年从 AT&amp;amp;A 授权来的 Unix OS，配合着 x86 成为当时最受欢迎的 Unix 发行版。后来 M$ 和 IBM 合作开发 OS/2 操作系统后放弃，后来最终转向 &lt;strong&gt;Windows NT&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;bsd&quot;&gt;BSD&lt;/h4&gt;
    &lt;p&gt;&lt;strong&gt;Barkeley Software Distribution&lt;/strong&gt;, also called Berkeley Unix. Today the term “BSD” is used to refer to any of the BSD descendants(后代) which together form a branch of the family of Unix-like OS.(共同组成了一个分支)&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;BSD 最大的贡献是在 BSD 中率先增加了虚拟存储器和 Internet 协议&lt;/strong&gt;，其 TCP/IP(IPv4 only) 代码仍然在现代 OS 上使用（ Microsoft Windows and most of the foundation of Apple’s OS X and iOS ）&lt;/li&gt;
      &lt;li&gt;BSD 后来发展出了众多开源后代，包括 FreeBSD, OpenBSD, NetBSD 等等……很多闭源的 vendor Unix 也都从 BSD 衍生而来。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;freebsd--apple&quot;&gt;FreeBSD &amp;amp; Apple&lt;/h4&gt;
    &lt;p&gt;FreeBSD 不但是 Open Source BSD 中占有率最高的，还直接影响了 Apple Inc : NeXT Computer 的团队在 FreeBSD 上衍生出了 NeXTSTEP 操作系统，这货后来在 Apple 时期演化成了 &lt;strong&gt;Darwin&lt;/strong&gt; ，这个“达尔文”居然还是个开源系统，而且是 the Core of &lt;strong&gt;Mac OS X&lt;/strong&gt; and &lt;strong&gt;iOS&lt;/strong&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;nextstep&quot;&gt;NeXTSTEP&lt;/h4&gt;
    &lt;p&gt;An &lt;strong&gt;object-oriented&lt;/strong&gt;, multitasking OS. Low-level C but High-level OC language and runtime the first time, combined with an &lt;strong&gt;OO aplication layer&lt;/strong&gt; and including several “kits”.  &lt;br /&gt;
大家都知道 NeXT 是 Steve Jobs 被 forced out of Apple 后和 a few of his coworkers 创办的，所以 &lt;strong&gt;NeXTSTEP 绝对是证明 Jobs 实力的作品。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;darwin&quot;&gt;Darwin&lt;/h4&gt;
    &lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Darwin_(operating_system\)&quot;&gt;Darwin&lt;/a&gt;, the core set of components upon which Mac OS X and iOS based, mostly POSIX compatible, but has never, by itself, been certified as being compatible with any version of &lt;strong&gt;POSIX&lt;/strong&gt;. (OS X, since Leopard, has been certified as compatible with the Single UNIX Specification version 3)&lt;br /&gt;
&lt;strong&gt;所以说 Mac OS X 算是很正统 Unix 的了&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;posix&quot;&gt;POSIX&lt;/h4&gt;
    &lt;p&gt;可移植操作系统接口, Portable Operating System Interface, is a family of standards specified by the IEEE from maintaining compatibility between OS, defines the API along with Command Line Shells and utility interfaces, for software comaptibility with variants of Unix and other OS.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Fully POSIX compliant:
        &lt;ul&gt;
          &lt;li&gt;OS X&lt;/li&gt;
          &lt;li&gt;QNX OS (BlackBerry)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Mostly complicant:
        &lt;ul&gt;
          &lt;li&gt;Linux&lt;/li&gt;
          &lt;li&gt;OpenBSD/FreeBSD&lt;/li&gt;
          &lt;li&gt;Darwin (Core of &lt;strong&gt;iOS&lt;/strong&gt; &amp;amp; OS X)&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Android&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Complicant via compatibility feature （通过兼容功能实现兼容）
        &lt;ul&gt;
          &lt;li&gt;Windows NT Kernel
            &lt;ul&gt;
              &lt;li&gt;Windows Server 2000, 2003, 2008, 2008 R2, 2012&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Symbian OS (with PIPS)
            &lt;ul&gt;
              &lt;li&gt;Symbian was a closed-source OS.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;unix-like&quot;&gt;Unix-like&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;A Unix-like (sometimes referred to as UN*X or *nix) operating system is one that behaves in a manner similar to a Unix system, while not necessarily conforming to or being certified to any version of the &lt;strong&gt;Single UNIX Specification&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There is no standard for defining the term.&lt;br /&gt;
其实 Unix-like 是个相对模糊的概念：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最狭义的 Unix 单指 Bell Labs’s Unix&lt;/li&gt;
  &lt;li&gt;稍广义的 Unix 指代所有 Licensed Unix, 即通过了 SUS 的 Unix-like ，比如 OS X&lt;/li&gt;
  &lt;li&gt;最广义的 Unix 即所有 Unix-like 系统，无论它是否通过过任何 SUS，包括 Linux，BSD Family 等&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;single-unix-specification&quot;&gt;Single UNIX Specification&lt;/h4&gt;
&lt;p&gt;The Single UNIX Specification (SUS) is the collective name of a family of standards for computer OS, compliance with which is required to &lt;strong&gt;qualify for the name “Unix”&lt;/strong&gt;, like &lt;strong&gt;POSIX&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;apple-ios&quot;&gt;Apple iOS&lt;/h4&gt;
&lt;p&gt;iOS is a &lt;strong&gt;Unix-like OS based on Darwin(BSD)&lt;/strong&gt; and OS X, which share some frameworks including Core Foundation, Founadtion and the Darwin foundation with OS X, but, Unix-like shell access is not avaliable for users and restricted for apps, &lt;strong&gt;making iOS not fully Unix-compatible either.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The iOS kernal is &lt;strong&gt;XNU&lt;/strong&gt;, the kernal of Darwin.&lt;/p&gt;

&lt;h4 id=&quot;xnu-kernel&quot;&gt;XNU Kernel&lt;/h4&gt;
&lt;p&gt;XNU, the acronym(首字母缩写) for &lt;strong&gt;&lt;em&gt;X is Not Unix&lt;/em&gt;&lt;/strong&gt;, which is the &lt;strong&gt;Computer OS Kernel&lt;/strong&gt; developed at Apple Inc since Dec 1996 for use in the Mac OS X and released as free open source software as part of Darwin.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;linux&quot;&gt;Linux&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux is a Unix-like and mostly POSIX-compliant computer OS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/Unix_timeline.en.svg/800px-Unix_timeline.en.svg.png&quot; alt=&quot;Unix_timeline&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;linux-kernel&quot;&gt;Linux Kernel&lt;/h4&gt;

&lt;p&gt;严格来讲，术语 Linux 只表示 &lt;a href=&quot;http://en.wikipedia.org/wiki/Linux_kernel&quot;&gt;Linux Kernel&lt;/a&gt; 操作系统内核本身，比如说 Android is Based on Linux (Kernel). Linus 编写的也只是这一部分，一个免费的 Unix-like Kernel，并不属于 GNU Project 的一部分。&lt;/p&gt;

&lt;p&gt;但通常把 Linux 作为 Linux Kernel 与大量配合使用的 GNU Project Software Kit (包括 Bash, Lib, Compiler, 以及后期的 GUI etc) 所组合成的 OS 的统称。（包括各类 Distribution 发行版）&lt;/p&gt;

&lt;p&gt;这类操作系统也被称为 &lt;strong&gt;GNU/Linux&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;gnu-project&quot;&gt;GNU Project&lt;/h4&gt;

&lt;p&gt;The GNU Project is a &lt;strong&gt;free software, mass collaboration&lt;/strong&gt; project, which based on the following freedom rights:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Users are free to run the software, share (copy, distribute), study and modify it.&lt;/li&gt;
  &lt;li&gt;GNU software guarantees these freedom-rights legally (via its license).&lt;/li&gt;
  &lt;li&gt;So it is not only FREE but, more important, FREEDOM.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In order to ensure that the &lt;em&gt;entire&lt;/em&gt; software of a computer grants its users all freedom rights (use, share, study, modify), even the most fundamental and important part, &lt;strong&gt;the operating system&lt;/strong&gt;, needed to be written.&lt;/p&gt;

&lt;p&gt;This OS is decided to called &lt;strong&gt;GNU (a recursive acronym meaning “GNU is not Unix”)&lt;/strong&gt;. By 1992, the GNU Project had completed all of the major OS components except for their kernel, &lt;em&gt;GNU Hurd&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;With the release of the third-party &lt;strong&gt;Linux Kernel&lt;/strong&gt;, started independently by &lt;em&gt;Linus Torvalds&lt;/em&gt; in 1991 and released under the GPLv0.12 in 1992, for the first time it was possible to run an OS &lt;strong&gt;composed completely of free software&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Though the Linux kernel is not part of the GNU project, it was developed using GCC and other GNU programming tools and was released as free software under the GPL.&lt;/p&gt;

&lt;p&gt;Anyway, there eventually comes to the &lt;strong&gt;GNU/Linux&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;GPL&lt;/strong&gt;: GNU General Public License&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GCC&lt;/strong&gt;: GNU Compiler Collection&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他与 GPL 相关的自由/开源软件公共许可证：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Mozilla_Public_License&quot;&gt;Mozilla Public License&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/MIT_License&quot;&gt;MIT License&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/BSD_licenses&quot;&gt;BSD Public License&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;GPL 强制后续版本必须是自由软件，而 BSD 的后续可以选择继续开源或者封闭&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Apache_License&quot;&gt;Apache License&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/open-source-license.png&quot; alt=&quot;Public License&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;android&quot;&gt;Android&lt;/h4&gt;

&lt;p&gt;Android is a mobile OS based on &lt;strong&gt;Linux Kernel&lt;/strong&gt;, so it’s definitely &lt;strong&gt;Unix-like&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linux is under GPL so Android has to be open source&lt;/strong&gt;. 
Android’s source code is released by Google under open source licenses, although most Android devices ultimately ship with a combination of open source and proprietary software, including proprietary software developed and licensed by Google &lt;em&gt;(GMS are all proprietary)&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;android-kernel&quot;&gt;Android Kernel&lt;/h4&gt;

&lt;p&gt;Android’s kernel is based on one of the Linux kernel’s long-term support (LTS) branches.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Android’s variant of the Linux kernel&lt;/strong&gt; has further architectural changes that are implemented by Google outside the typical Linux kernel development cycle, and, certain features that Google contributed back to the Linux kernel. Google maintains a public code repo that contains their experimental work to re-base Android off the latest stable Linux versions.&lt;/p&gt;

&lt;p&gt;Android Kernel 大概是 Linux Kernel 最得意的分支了，Android 也是 Linux 最流行的发行版。不过，也有一些 Google 工程师认为 Android is not Linux in the traditional Unix-like Linux distribution sense. 总之这类东西就算有各种协议也还是很难说清楚，在我理解里 Android Kernel 大概就是 fork Linux Kernel 之后改动和定制比较深的例子。&lt;/p&gt;

&lt;h4 id=&quot;android-rom&quot;&gt;Android ROM&lt;/h4&gt;

&lt;p&gt;既然提到 Android 就不得不提提 Android ROM&lt;/p&gt;

&lt;p&gt;ROM 的本义实际上是只读内存：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Read-only memory&lt;/strong&gt; (ROM) is a class of storage medium used in computers and other electronic devices. Data stored in ROM can only be modified slowly, with difficulty, or not at all, so it is &lt;strong&gt;mainly used to distribute firmware (固件)&lt;/strong&gt; (software that is very closely tied to specific hardware, and unlikely to need frequent updates).&lt;/p&gt;

&lt;p&gt;ROM 在发展的过程中不断进化，从只读演变成了可编程可擦除，并最终演化成了 Flash&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PROM (Programmable read-only memory)&lt;/li&gt;
  &lt;li&gt;EPROM (Erasable programmable read-only memory)&lt;/li&gt;
  &lt;li&gt;EEPROM (Electrically erasable programmable read-only memory)
    &lt;ul&gt;
      &lt;li&gt;Flash memory (闪存)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Flash 的出现是历史性的，它不但可以作为 ROM 使用，又因其极高的读写速度和稳定性，先后发展成为U盘（USB flash drives）、移动设备主要内置存储，和虐机械硬盘几条街的固态硬盘（SSD），可以说这货基本统一了高端存储市场的技术规格。&lt;/p&gt;

&lt;p&gt;所以我们平时习惯说的 ROM 其实还是来源于老单片机时代，那时的 ROM 真的是写了就很难（需要上电复位）、甚至无法修改，所以那时往 ROM 里烧下去的程序就被称作 firmware ，固件。久而久之，虽然技术发展了，固件仍然指代那些不常需要更新的软件，而 ROM 这个词也就这么沿用下来了。&lt;/p&gt;

&lt;p&gt;所以在 wiki 里是没有 Android ROM 这个词条的，只有 &lt;a href=&quot;http://en.wikipedia.org/wiki/List_of_custom_Android_firmwares&quot;&gt;List of custom Android firmwares&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A custom firmware, also known as a custom ROM, ROM, or custom OS, is an aftermarket distribution of the Android operating system. They are based on the Android Open Source Project (AOSP), hence most are open-sourced releases, unlike proprietary modifications by device manufacturers.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;各类 Android ROM 在 Android 词类下也都是属于 &lt;strong&gt;Forks and distributions&lt;/strong&gt; 一类的。&lt;/p&gt;

&lt;p&gt;所以我说，其实各类 Android ROM 也好，fork Android 之流的 YunOS、FireOS 也好，改了多少东西，碰到多深的 codebase ……&lt;strong&gt;其实 ROM 和 Distribution OS 的界限是很模糊的&lt;/strong&gt;，为什么 Android 就不可以是移动时代的 Linux ，为什么 Devlik/ART 就不能是移动时代的 GCC 呢？&lt;/p&gt;

&lt;h4 id=&quot;chrome-os&quot;&gt;Chrome OS&lt;/h4&gt;

&lt;p&gt;Chrome OS is an operating system based on the &lt;strong&gt;Linux kernel&lt;/strong&gt; and designed by Google to work with web applications and installed applications.&lt;/p&gt;

&lt;p&gt;虽然目前只是个 Web Thin Client OS ，但是 RoadMap 非常酷……&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Chrome Packaged Application&lt;/strong&gt; (Support working offline and installed)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Android App Runtime&lt;/strong&gt; (run Android applications natively…fxxking awesome)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;平复一下激动的心情，还是回到正题来：&lt;/p&gt;

&lt;h4 id=&quot;chromium-os&quot;&gt;Chromium OS&lt;/h4&gt;

&lt;p&gt;Chrome OS is based on Chromium OS, which is the open-source development version of Chrome OS, which is a &lt;strong&gt;Linux distribution&lt;/strong&gt; designed by Google.&lt;/p&gt;

&lt;p&gt;For Detail, Chromium OS based on &lt;a href=&quot;http://en.wikipedia.org/wiki/Gentoo_Linux&quot;&gt;Gentoo Linux&lt;/a&gt;, emm…&lt;/p&gt;

</description>
        <pubDate>Tue, 14 Apr 2015 00:00:00 +0000</pubDate>
        <link>http://wanglizhi.github.io/2015/04/14/unix-linux-note/</link>
        <guid isPermaLink="true">http://wanglizhi.github.io/2015/04/14/unix-linux-note/</guid>
        
        <category>OS</category>
        
        <category>Unix</category>
        
        <category>Linux</category>
        
        
      </item>
    
      <item>
        <title>「知乎」你们觉得响应式好呢，还是手机和PC端分开来写？</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这篇文章转载自&lt;a href=&quot;http://www.zhihu.com/question/25836425/answer/31564174&quot;&gt;我在知乎上的回答&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div&gt;
	&lt;p&gt;
		&lt;b&gt;根据你的产品特点，进行两种不同的设计，&lt;/b&gt;
	    &lt;br /&gt;&lt;b&gt;根据你的设计需求，选择合适的技术方案&lt;/b&gt;。
    &lt;/p&gt;
    &lt;br /&gt;&lt;b&gt;A与B不是硬币的正反面，它们为了解决同一个问题而生，它们是同一种思想的延伸。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;blockquote&gt;移动和桌面设计的差别远不止是布局问题。只要有足够的编程量，这些差别是可以通过响应式设计来解决的。事实上，你可以认为如果一种设计不能兼顾两种平台的主要差别，就不能算是合格的响应式设计。但是，如果确实想要处理好平台间的所有差异，我们就回到了原点：进行两种不同的设计。
        &lt;br /&gt;
        &lt;br /&gt;——《Mobile Usability》（《贴心设计 打造高可用性的移动产品》）&lt;/blockquote&gt;
    &lt;br /&gt;
    &lt;br /&gt;其实无论是什么解决方案，我们先来看看我们想要解决的问题：
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;“屏幕尺寸越来越多，不同设备的交互特质也有着巨大的差别，我们希望我们的网站能够在移动手机、平板、桌面电脑，在键鼠、触摸、无障碍设备上都有优秀的用户体验。所以，我们需要网站的用户界面在不同的平台上有所不同。”&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;那怎么做呢，一个解决方案应运而生：
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;b&gt;响应式设计 (Responsive Web design)&lt;/b&gt;
        &lt;/li&gt;
    &lt;/ul&gt;&lt;b&gt;狭义上&lt;/b&gt;，我们把&lt;b&gt;主要依靠前端 CSS&lt;/b&gt; （包括 Media Query 媒体查询，百分比流式布局，网格与Typography系统……）来对各种屏幕尺寸进行响应的做法，称之为响应式布局，又称作自适应网页设计，或者弹性设计。
    &lt;br /&gt;
    &lt;br /&gt;这种主要依靠CSS的方案有很多优点，比如：
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;ul&gt;
            &lt;li&gt;设计元素很容易被复用，设计成本低&lt;/li&gt;
            &lt;li&gt;前端只需要维护一套CSS代码，&lt;b&gt;维护成本&lt;/b&gt;低&lt;/li&gt;
            &lt;li&gt;桌面端与移动端的设计十分接近，令用户感到“熟悉”&lt;/li&gt;
            &lt;li&gt;不需要任何服务器端的支持&lt;/li&gt;
            &lt;li&gt;与业务耦合程度低，复用程度高（ 以至于 Bootstrap、Foundation 等一干框架都跟进了这个解决方案 ）&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/ul&gt;但问题也很明显，比如：
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;ul&gt;
            &lt;li&gt;设计需求复杂时，前端的&lt;b&gt;开发成本&lt;/b&gt;没有任何减轻&lt;/li&gt;
            &lt;li&gt;无论是针对桌面还是移动的CSS代码（甚至图片资源文件）都会被同等的下载到客户端（&lt;b&gt;没有考虑移动端的网络优化&lt;/b&gt;）&lt;/li&gt;
            &lt;li&gt;如果JS不写两套，桌面端的交互和移动端的交互很难针对平台作出差异&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/ul&gt;
    &lt;br /&gt;
    &lt;br /&gt;如果&lt;b&gt;你的&lt;/b&gt;&lt;b&gt;移动用户对网站所有的功能和内容有着与桌面用户同等的需求&lt;/b&gt;，比如 新闻、报纸（媒体类）网站，或者活动、专题页等 &lt;b&gt;偏重信息传达而轻交互 &lt;/b&gt;的网站，那么这个解决方案其实恰到好处：
    &lt;br /&gt;&lt;b&gt;触摸屏优化（胖手指）、减少次要信息…… 这些通过 CSS 解决就够了。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;但是，如果我想要做更多的 「移动化设计」，比如 减少信息层级、增强手势操作、让网页更接近一个Native App ？&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;好吧，为了更复杂的需求，为了我们的网站能更牛逼的 &lt;b&gt;「响应」&lt;/b&gt; 各个平台，
    &lt;br /&gt;又有了这些解决方案：
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;b&gt;服务器端（后端）：&lt;/b&gt;
            &lt;br /&gt;
        &lt;/li&gt;
        &lt;ul&gt;
            &lt;li&gt;RESS （Responsive Web Design with Server Side Components）通过服务器端组件的响应式网页设计&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/ul&gt;提倡 RESS 的人认为：基于前端 CSS 的响应式方案只是一种妥协：
    &lt;br /&gt;&lt;b&gt;“ UI 只是在很被动的进行「调整」，而不能真正达到各个平台的最优。好的设计应该达到「这个设备该有的体验」（Device Experiences）。 ”&lt;/b&gt;
    &lt;br /&gt;
    &lt;blockquote&gt;&lt;b&gt;Device Experiences ：&lt;/b&gt;A device experience is defined by how a device is most commonly used and the technical capabilities or limitations it possesses.&lt;/blockquote&gt;RESS 的本质还是服务器端动态的生成，返回 HTML、JS、CSS、图像等资源文件，但是只使用同一个 URL 就可以提供给移动端定制化更强的网页，同时还大大节省了网络资源。
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;b&gt;前端&lt;/b&gt;（主要是JS），比如：
            &lt;br /&gt;
        &lt;/li&gt;
        &lt;ul&gt;
            &lt;li&gt;在 JavaScript 中实现两套逻辑，分别兼容键鼠、触摸设备&lt;/li&gt;
            &lt;li&gt;通过 UA、特性检测 在前端做设备判断，对资源进行异步加载，渲染不同模版&lt;/li&gt;
            &lt;li&gt;通过 特性检测 在前端做设备判断，使用不同的业务逻辑&lt;/li&gt;
            &lt;li&gt;前端的模块化也可以帮助解决这个问题，比如针对不同的平台加载不同的模块&lt;/li&gt;
            &lt;li&gt;……&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/ul&gt;
    &lt;br /&gt;
    &lt;br /&gt;这下，我们的网站可以更牛逼的 &lt;b&gt;“响应”&lt;/b&gt; 各个平台了。
    &lt;br /&gt;（对，我还是称之为响应：这的确还是在&lt;b&gt;“响应”&lt;/b&gt;啊 ，不是吗？）
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;但是等下……&lt;/b&gt;
    &lt;br /&gt;后端开发成本上去了，前端开发成本也上去了，配合着估计产品、设计资源也都上去了，&lt;b&gt;那我们为什么不干脆把 移动设备网站 和 桌面设备网站 分开呢！？&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;是啊，如果你的需求真的都到这一步了，你的移动网站也应该可以被称作 WebApp 了。&lt;b&gt;这种时候，把移动设备网站彻底分开或许真的是更好的选择。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;开发资源如此充足，你还可以让专门的团队来维护移动端的网站。
    &lt;br /&gt;（嗯，BAT 就是这么干的）
    &lt;br /&gt;
    &lt;br /&gt;于是又一个概念来了：
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;b&gt;独立的移动版网站&lt;/b&gt; （按题主的话来说：手机和PC端分开来写）&lt;/li&gt;
    &lt;/ul&gt;不过，它有那么独立么？
    &lt;br /&gt;我们知道，我们访问网站是通过 URL 来访问的。
    &lt;br /&gt;将移动网站 和 桌面网站 分开，如果不使用 RESS 技术，往往也就意味着要维护两个URL（不同的二级域名）
    &lt;br /&gt;难道我们要让所有桌面用户自觉访问 &lt;a href=&quot;http://taobao.com&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;taobao.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; ，所有 移动用户 都自觉访问 &lt;a href=&quot;http://m.taobao.com&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;m.taobao.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;&lt;/span&gt;&lt;i class=&quot;icon-external&quot;&gt;&lt;/i&gt;&lt;/a&gt; ？
    &lt;br /&gt;
    &lt;br /&gt;不可能吧 ＝ ＝。
    &lt;br /&gt;
    &lt;br /&gt;于是，我们还是得依靠前端或服务器端的一次 &lt;b&gt;“响应”&lt;/b&gt;（设备检测），做 URL 重定向，才能将不同设备的用户带到那个为他们准备的网站。
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;所以其实在我看来，手机和PC端分开来写，只是 狭义响应式设计 的一种发展和延伸罢了。他们的界限没有，也并不需要那么清晰。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;就如开题所引用的：
    &lt;br /&gt;
    &lt;blockquote&gt;&lt;b&gt;事实上，你可以认为如果一种设计不能兼顾两种平台的主要差别，就不能算是合格的响应式设计。&lt;/b&gt;
    &lt;/blockquote&gt;&lt;b&gt;“而无论是用什么解决方案。” —— 这句是我补的。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;故我的结论是：
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;这不是一个二选一的问题，而是选择一个合适的度&lt;/b&gt;（你的桌面版本代码与移动版本代码分离、耦合的程度）
    &lt;br /&gt;
    &lt;br /&gt;而这个度，则是由你的设计需求决定的。
    &lt;br /&gt;而我们的需求原点其实也很简单：
    &lt;br /&gt;
    &lt;br /&gt; “&lt;b&gt;根据你的产品特点，进行两种不同的设计&lt;/b&gt;”。
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;以上。
    &lt;br /&gt;
    &lt;br /&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 20 Nov 2014 12:00:00 +0000</pubDate>
        <link>http://wanglizhi.github.io/2014/11/20/responsive-web-design/</link>
        <guid isPermaLink="true">http://wanglizhi.github.io/2014/11/20/responsive-web-design/</guid>
        
        <category>知乎</category>
        
        <category>前端开发</category>
        
        
      </item>
    
      <item>
        <title>「知乎」为什么阿里系软件体验都不好？</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这篇文章转载自&lt;a href=&quot;http://www.zhihu.com/question/25657351/answer/31278511&quot;&gt;我在知乎上的回答&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div&gt;
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;一言以蔽之，优先级。&lt;/b&gt;
    &lt;br /&gt;这个优先级并不是由谁或者哪个Boss定的，而是&lt;b&gt;长期的市场竞争和业务需求下的结果&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;b&gt;为什么企鹅家的App用户体验较好？&lt;/b&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
    企鹅家的主力产品，QQ、微信、QQ音乐、QQ空间 等，多是IM（即时通讯）、SNS（社交网络）、数字娱乐 等形态的产品。
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;这类产品往往必须「直接依靠优秀的产品服务与用户体验」来赢得用户。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;如果这点做不好，产品就无法在竞争中脱颖而出。这也使得在企鹅内部，&lt;b&gt;围绕这部分的要求，需求，反馈 &lt;/b&gt;&lt;b&gt;都一定最多，使得企鹅不得不把这部分做好&lt;/b&gt;。
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;b&gt;那为什么阿里系的App用户体验较差？&lt;/b&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
    阿里系的主力产品，从1688、淘宝、再到支付宝、天猫、淘宝旅行、淘点点、一淘、旺旺，要么是电商类产品，要么就是电商类的延伸产品。
    &lt;br /&gt;
    &lt;br /&gt;而这类产品的核心竞争力（或者说要做好的难处），往往在&lt;b&gt;「如何与实体经济，甚至政府 打交道」、&lt;/b&gt;&lt;b&gt;「如何做好运营」，&lt;/b&gt;而非优秀的用户体验。
    &lt;br /&gt;
    &lt;br /&gt;应该说，阿里从来都不是不重视用户体验，这两年更是愈发重视。但是因为身处这样的市场环境，&lt;b&gt;阿里必须先完成这些优先级更高的需求（海量的业务，运营需求）以抢占市场，&lt;/b&gt;
    &lt;br /&gt;这才导致阿里内部无法有太多精力focus到客户端体验上。
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;上面就算基本回答了题主的问题，
    &lt;br /&gt;不过，知乎惯例，多说几句：
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;其实，上面的答案，也可以说这都是说辞。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;在我刚刚加入阿里的时候，我也一度纳闷甚至郁闷这个事。直到我开始接触更多的项目，我才能逐渐理解「为什么会这样」。
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;但是，这并不足以成为借口。&lt;/b&gt;
    &lt;br /&gt;&lt;b&gt;该不该改？ 当然该改。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;我相信几乎所有阿里人，尤其UED，肯定都不希望这样。
    &lt;br /&gt;只能说，这需要阿里投入更多的人、更多的时间、更多的努力来做好
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;以上。
    &lt;br /&gt;
    &lt;br /&gt;利益相关：
    &lt;br /&gt;阿里员工
    &lt;br /&gt;
    &lt;br /&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 01 Oct 2014 12:00:00 +0000</pubDate>
        <link>http://wanglizhi.github.io/2014/10/01/why-alibaba-ux-sucks/</link>
        <guid isPermaLink="true">http://wanglizhi.github.io/2014/10/01/why-alibaba-ux-sucks/</guid>
        
        <category>知乎</category>
        
        <category>阿里巴巴</category>
        
        <category>交互设计</category>
        
        
      </item>
    
      <item>
        <title>「知乎」对中国用户而言，Pure Android 是否比 MIUI 或 Flyme 体验更好？</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这篇文章转载自&lt;a href=&quot;http://www.zhihu.com/question/25104721/answer/30108886&quot;&gt;我在知乎上的回答&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;哎呀～不要站队嘛。其实这是一个很有意思的题目，让我们一点点来看
    &lt;br /&gt;
    &lt;br /&gt;哦对，谢妖～。本人是Nexus 5用户，系统当然是Pure Android KitKat啦（臭谷粉！点Down！喂喂喂我还没给结论呢）
    &lt;br /&gt;&lt;b&gt;毕竟是回答问题嘛，先给一个明确的答案&lt;/b&gt;：
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;否。（&lt;/b&gt;&lt;b&gt;对中国用户而言，Pure Android 并不比 MIUI 或 Flyme 体验更好。&lt;/b&gt;&lt;b&gt;）&lt;/b&gt;
    
    &lt;p&gt;从下面「 居然比关注数还多」的回答中，就可以看出大家都是急于站队的样子：&lt;/p&gt;
    
    &lt;ul&gt;
        &lt;li&gt;Google Service！翻墙很轻松好吗！Geek站过来，有品味绝逼原生阿。&lt;/li&gt;
        &lt;li&gt;没用过Pure，国内Google能用！？本地化多重要，易用果断MIUI/Flyme 啊！（咦 米粉和魅粉居然在一致对外上达成了共识）&lt;/li&gt;
    &lt;/ul&gt;
    &lt;br /&gt;从答案我们也可以看出，中国用户的确是一个过于复杂的群体，那这个问题怎么办？
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;数学老师教过哒，分类讨论啊！&lt;/b&gt;
    &lt;br /&gt;（来，开始认真了。注意，我只分两类，数量非常小的Geek用户，和其余都算在内的非Geek用户）
    &lt;br /&gt;
    &lt;br /&gt;

    &lt;p&gt;先说好理解的：&lt;/p&gt;
    
    &lt;ul&gt;
        &lt;li&gt;&lt;b&gt;为什么 Geek 用户 都爱使用Pure Android？：&lt;/b&gt;
        &lt;/li&gt;
    &lt;/ul&gt;在国内，使用Pure Android其实是有很多障碍的：众所周知Google基本被墙死，去年还能上上的G+，Gmail 最近基本报废，回国后Google Now不开VPN永远都是Sign error或者No internet connection……那干嘛还用？
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;因为这群人是Geek呀！&lt;/b&gt;这群谷粉、安卓粉、IT科技粉、设计师、工程师们，这群充满技术情节的人儿们，为了我们的品味（逼格），挂着VPN，连着美版的Play Store，用着Android/Material Design 的 GMS，Chrome Beta，FB，Twitter，WhatsApp……就这么一路高歌的走下去了。
    &lt;br /&gt;
    &lt;br /&gt;你看！Action Bar ＋ Navigation Drawer 多好用！
    &lt;br /&gt;你看！Fixed Tabs 可以滑的好吗！
    &lt;br /&gt;你看！流畅不！ART开起来妥妥的流畅度爆iOS！
    &lt;br /&gt;你看！原生Android 哪里会越用用卡！？你升4.4.4了吗 ？
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;哪里要担心这群人啊。&lt;/b&gt;国内买不到的Nexus，用不了GMS，这都不叫事。
    &lt;br /&gt;
    &lt;br /&gt;

    &lt;p&gt;那么，&lt;/p&gt;

    &lt;ul&gt;
        &lt;li&gt;&lt;b&gt;为什么 非Geek 用户 不适合使用Pure Android？：&lt;/b&gt;
        &lt;/li&gt;
    &lt;/ul&gt;GMS的问题就不多说了，妥妥是用不了，在VPN之间切换也是麻烦。
    &lt;br /&gt;也不说Pure Android不那么好刷到的问题（当然你可以刷CM），
    &lt;br /&gt;我们就直接来看最核心的问题：
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;「 Pure Android 的交互设计真的比 MIUI / Flyme 好吗？」&lt;br /&gt;&lt;/b&gt;
    &lt;br /&gt;&lt;b&gt;不见得。&lt;/b&gt;
    &lt;br /&gt;&lt;b&gt;所谓设计，第一个要考虑的就是目标用户。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;为什么Pure Android的交互设计让Geek觉得用户体验好？
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;li&gt;国外规范的 Android Design 生态环境打造统一的 Pure Android 体验&lt;/li&gt;
        &lt;li&gt;更高级的手势/App运用带来了很多便利（典型的例子SwipePad）&lt;/li&gt;
        &lt;li&gt;有着工程师思想的他们可以轻易理解Android的复杂逻辑&lt;/li&gt;
        &lt;li&gt;有着工程师思想的他们总能自己轻松躲开一些设计问题&lt;/li&gt;
    &lt;/ul&gt;
    &lt;br /&gt;而 Pure Android 之于 普通用户 呢？
    &lt;br /&gt;&lt;b&gt;「 这些优势基本荡然无存」&lt;/b&gt;，反而，混乱的国内生态环境带来大部分中国用户对Android Design的陌生，相比iOS复杂许多的Android逻辑带来较高的学习成本……
    &lt;br /&gt;
    &lt;br /&gt;而MIUI/Flyme在设计方面上的本地化，主要就是出来解决这个问题的。
    &lt;br /&gt;我们可以看到，其实MIUI/Flyme做得大部分工作，除了视觉外，就是&lt;b&gt;简化信息层级，降低交互学习成本，遮住Android系统过于复杂的部分，在易用性上向iOS靠拢&lt;/b&gt;。
    &lt;br /&gt;
    &lt;br /&gt;如果说在这里MIUI/Flyme还只能和Pure Android 打个平手的话……
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;MIUI 和 Flyme 的本地化还远没有完：&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;你在国内总要用国内的互联网服务吧？
    &lt;br /&gt;&lt;b&gt;集成，&lt;/b&gt;我全给你全整合进来，打造一条龙服务
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;li&gt;应用商店
            &lt;br /&gt;
        &lt;/li&gt;
        &lt;li&gt;云存储/云服务（自己提供或合作）
            &lt;br /&gt;
        &lt;/li&gt;
        &lt;li&gt;数字娱乐消费（音乐/游戏/阅读/视频/主题/壁纸/铃声……）
            &lt;br /&gt;
        &lt;/li&gt;
        &lt;li&gt;安全（小白最爱用的系统清理，陌生号码拦截……）
            &lt;br /&gt;
        &lt;/li&gt;
        &lt;li&gt;生活服务（支付，地图，快递，订餐，打车，旅游……）
            &lt;br /&gt;
        &lt;/li&gt;
        &lt;li&gt;社交（美图，快速分享……）
            &lt;br /&gt;
        &lt;/li&gt;
        &lt;li&gt;太多了。总之就是你想要什么有什么，自己没有就跟大家合作呗。
            &lt;br /&gt;
        &lt;/li&gt;
    &lt;/ul&gt;&lt;b&gt;不够酷？&lt;/b&gt;对大部分用户来说够酷了
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;li&gt;小米，平板，盒子，电视，路由……MIUI的多屏体验&lt;/li&gt;
        &lt;li&gt;魅族，联合智能硬件，手表飞机插座……Connect to Meizu&lt;/li&gt;
    &lt;/ul&gt;&lt;b&gt;渠道成本低（不是指价格）&lt;/b&gt;。这个其实也相当重要
    &lt;br /&gt;
    &lt;ul&gt;
        &lt;li&gt;容易刷到，适配机子广，稳定。&lt;/li&gt;
        &lt;li&gt;国内买得到，线下甚至有体验店，可以教你用呀什么的。&lt;/li&gt;
    &lt;/ul&gt;
    &lt;br /&gt;更何况，对于大部分非Geek用户，手机虽不再只是当年的通讯工具那么简单，但充其量也就是一个智能电子设备而已。&lt;b&gt;能方便快速的享受到国内主流的互联网应用与服务，完成日常的需求就足以&lt;/b&gt;。
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;MIUI/Flyme 在这方面上的成绩，是Pure Android远不能比的。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;所以我的结论是：
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;对中国用户而言，Pure Android 并不比 MIUI 或 Flyme 体验更好。&lt;/b&gt;
    &lt;br /&gt;&lt;b&gt;对大部分中国用户而言，MIUI 或 Flyme 比 &lt;/b&gt;&lt;b&gt;Pure Android 的&lt;/b&gt;&lt;b&gt;体验更好。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;没啥利益相关，我又不是云OS的
&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Sep 2014 12:00:00 +0000</pubDate>
        <link>http://wanglizhi.github.io/2014/09/04/is-pure-android-better/</link>
        <guid isPermaLink="true">http://wanglizhi.github.io/2014/09/04/is-pure-android-better/</guid>
        
        <category>知乎</category>
        
        <category>交互设计</category>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>「知乎」如何评价 MIUI 6？</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这篇文章转载自&lt;a href=&quot;http://www.zhihu.com/question/24783844/answer/29286896&quot;&gt;我在知乎上的回答&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div&gt;
    &lt;blockquote&gt;MIUI 6，充满了“借鉴”，iOS 7 版的 Android……
        &lt;br /&gt;米 4，碉堡了，不服跑个分，简直就是 iPhone 4……&lt;/blockquote&gt;你们说得这些我一点都不反对。
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;可是，你们对小米的要求太高了&lt;/b&gt;。
    &lt;br /&gt;
    &lt;br /&gt;其实小米说到底也不过是一个才初创4年的公司而已，
    &lt;br /&gt;&lt;b&gt;你是指望小米能引领一套新的设计风格？&lt;/b&gt;
    &lt;br /&gt;&lt;b&gt;还是指望它能在国际上体现一下我国的自主创新能力？&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;你想太多了。
    &lt;br /&gt;
    &lt;br /&gt;更何况，&lt;b&gt;MIUI也不是没有设计&lt;/b&gt;，它比很多国内，国际大厂的ROM好看好用太多了。
    &lt;br /&gt;它只是没有多少新设计而已， iOS 7 的视觉，混着大部分 Android ＋ WP 的交互。也不知道是因为确实欣赏 Android 的一些交互，还是因为毕竟是基于 Android 懒得改了。
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;因为没有一个背后的设计思想在支撑，于是它就把所有自己觉得好，觉得会被认可的东西抄过来了而已。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;这思路一点问题都没有，&lt;/b&gt;&lt;b&gt;大部分用户一定会觉得更好看了&lt;/b&gt;，国际范儿又有设计感。最多是少数圈内人士（包括我），那群也不真正买它手机用的人，在那愤愤不平而已。
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;自立门派风险太大了。&lt;/b&gt;
    &lt;br /&gt;&lt;b&gt;MI 4 的配置 + MIUI 6，在这个价位几乎是无敌的，这就够了。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;至于官方说的什么“糖果式”设计，那简直就是笑话。跟 Ive 的 iOS 7 或是 Material Design，Metro 所设计之设计，完全不在一个高度上。
    &lt;br /&gt;
    &lt;br /&gt;
    &lt;br /&gt;其实有的时候觉得小米很像腾讯（尤其是更早些年的腾讯）。
    &lt;br /&gt;&lt;b&gt;其实本来也就不是什么创新者的角色，那就做借鉴和整合呗。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;用户喜欢什么，
    &lt;br /&gt;公司需要什么，
    &lt;br /&gt;大众流行什么，
    &lt;br /&gt;那我们就做呗。
    &lt;br /&gt;
    &lt;br /&gt;&lt;b&gt;拿下市场才是第一位的，不出错才是第一位的&lt;/b&gt;。
    &lt;br /&gt;&lt;b&gt;先做大了才有可能去做更大的事啊&lt;/b&gt;。
    &lt;br /&gt;
    &lt;br /&gt;老罗再有情怀，锤子要是死了，那也就这么死了。
    &lt;br /&gt;
    &lt;br /&gt;你指责小米没有多少创新，或是腾讯老是山寨 start up ，我同意，我陪你愤愤不平，可是又有什么意思呢。
    &lt;br /&gt;
    &lt;br /&gt;它们这么做，对现有公司发展来说，
    &lt;br /&gt;&lt;b&gt;简直是一点错都没有。&lt;/b&gt;
    &lt;br /&gt;
    &lt;br /&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 16 Aug 2014 12:00:00 +0000</pubDate>
        <link>http://wanglizhi.github.io/2014/08/16/miui6/</link>
        <guid isPermaLink="true">http://wanglizhi.github.io/2014/08/16/miui6/</guid>
        
        <category>知乎</category>
        
        <category>MIUI</category>
        
        <category>Android</category>
        
        
      </item>
    
  </channel>
</rss>
